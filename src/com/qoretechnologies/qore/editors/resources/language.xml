<?xml version="1.0" encoding="UTF-8" ?>

<chapter id="Qore_Language_Description">
  <title>Qore Language Description</title>

  <sect1 id="Language_Overview">
    <title>Language Overview</title>

    <para>A Qore program is composed of a series of declarations, statements, subroutine definitions, and/or class definitions. Non-block statements are terminated by a semi-colon ";". Block statements are grouped by using curly brackets ("{" and "}"), as in C, C++, Java, and Perl.</para>
    
    <para>Programmers familiar with C, C++, Java, and/or Perl should find the standard Qore syntax intuitive and should be productive fairly quickly with the language. However Qore has unique features that differentiate it from other languages, and these features must be mastered in order to leverage the full power of Qore.</para>
    
    <para>Qore programs/scripts are free form. Formatting does not affect the execution of the program; formatting is at the discretion of the programmer and should be used to enhance readability and clarity of the source code.</para>
    
    <para>Qore is a weakly typed language. That means that variables can hold values of any type and subroutines can return any value type (or none at all, see <link linkend='Variables'>Variables</link>). Furthermore list elements can be of any type (they do not have to be uniform), and multidimensional lists can have a different number of elements in each list. The same type flexibility holds true of hashes, objects, and all combinations of container types.</para>
    
    <para>Qore can be used a a traditional subroutine-based scripting language or as a pure object-oriented language, where the application is defined as a class. Aside from traditional local and global variables, constants, and subroutines, Qore also supports nested namespaces, classes, multiple inheritance, overriding base class constructor arguments, and private members and methods.</para>
    
    <para>All elements of Qore are designed to work together seamlessly: <link linkend="Qore::SQL::Datasource_Class">database access</link>, <link linkend="XML_Integration">XML transformations</link>, <link linkend="Qore_Socket_Class">socket communication</link>, <link linkend="Qore_Program_Class">embedding logic</link> in subprograms, regular expressions, <link linkend="Operators">operators</link>, <link linkend="Function_Library">functions</link>, and all other elements are thread-safe and built on an execution engine that was designed for SMP scalability.</para>

    <para>Qore automatically converts data types when necessary when evaluating operators. The goal is to provide the expected result for the programmer without requiring the programmer to explicitly convert data types. Please see section <link linkend='Operators'>Operators</link> for more information.</para>

    <para>UNIX operating systems allow an executable script to specify their interpreter. This is done by setting the first line in the program to a special string indicating the location of the Qore binary. For the purposes of this document, the location for the Qore binary is assumed to be <code>/usr/bin/qore</code>. The first line of Qore scripts in this case should look as follows:</para>

    <programlisting>#!/usr/bin/qore</programlisting>

    <para>If another installation directory is used (such as <code>/usr/local/bin</code>), then the correct path must be reflected in the first line of the Qore script.</para>

    <para>Qore convention dictates that Qore script file names end with <code>.q</code>.</para>
  </sect1>

  <sect1 id="Environment_Variables">
    <title>Environment Variables</title>

    <para>This section will outline the environment variables that are used by Qore.</para>

    <table frame='all'><title>Qore Environment Variables</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <thead>
	<row>
	  <entry><para>Environment Variable</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
  
      <tbody>
	<row>
	  <entry><para><code>QORE_AUTO_MODULE_DIR</code></para></entry>
	  <entry><para>This environment variable should contain a colon-separated list of directories which will be searched for Qore modules when Qore starts. If any modules are found, they are loaded automatically before any parsing starts.</para></entry>
	</row>
	<row>
	  <entry><para><code>QORE_MODULE_DIR</code></para></entry>
	  <entry><para>This environment variable should contain a colon-separated list of directories which will be searched when modules are loaded with the <code>%requires</code> parse directive</para></entry>
	</row>
	<row>
	  <entry><para><code>QORE_INCLUDE_DIR</code></para></entry>
	  <entry><para>This variable should be a colon-separated list 
	  of directories where the Qore binary should look for include 
	  files</para></entry>
	</row>
	<row>
	  <entry><para><code>QORE_CHARSET</code></para></entry>
	  <entry><para>If this variable is set, then the default character set name for the process will be the value of this variable.  This variable takes precedence over the <code>LANG</code> variable, but can be overridden by the command line using option <code>--charset</code> (see Section <link linkend='Qore_Strings_and_Character_Set_Encoding'>Qore Strings and Character Set Encoding</link> for more information on this option)</para></entry>
	</row>
	<row>
	  <entry><para><code>LANG</code></para></entry>
	  <entry><para>If this variable is set and includes a character set specification, then, if the <code>QORE_CHARSET</code> variable is not set (and no character set was specified on the command line), this character set will be the default for the process.</para></entry>
	</row>
      </tbody>
      
    </tgroup>
    </table>
    
  </sect1>
  
  <sect1 id="Qore_Modules">
    <title>Qore Modules</title>
    <para>Qore modules allow the Qore language to be extended at run-time.  Qore modules must conform to the Qore Module API and have the file extension <command><code>*.qmod</code></command>.</para>
    <para>Modules shipping with Qore include <link linkend="oracle_Module"><code>oracle</code></link>, <link linkend="mysql_Module"><code>mysql</code></link>, <link linkend="ncurses_Module"><code>ncurses</code></link>, and <link linkend="tibco_Module"><code>tibco</code></link>.</para>
    <para>To load a module, use the <code>%requires</code> parse directive. If the named feature is not already present in Qore, Qore looks for a module with this name in the directories listed in the <code>QORE_MODULE_DIR</code> environment variable.</para>
  </sect1>
  
  <sect1 id="Include_Files">
    <title>Include Files</title>
  
    <para>A Qore program can include other program code to be used and executed in the current program by using the <code>%include</code> directive. The <code>%include</code> directive must be the first text on the line, and the file name to include must follow. All text on the line after the <code>%include</code> directive will be used for the file name to include. The file name should not be quoted.</para>
    
    <para>Here is an example:</para>
    
    <programlisting>#!/usr/bin/qore
%include /usr/qore/lib/functions.lib</programlisting>
    
    <para>After this, any variable, subroutine, namespace, constant, or object declared in the above file can be used by the Qore program.</para>
    
    <para>The <code>QORE_INCLUDE_DIR</code> environment variable determines the search path for include files.</para>
    
  </sect1>
  <sect1 id="Identifiers">
    <title>Identifiers</title>

    <para>Qore identifiers must start with an alphabetic character, and then may contain any number of alphabetic, numeric, or "_" characters.  There is no length limit on Qore identifiers.</para>
    
    <para>All Qore identifiers are case-sensitive, therefore the identifier <code>hello_there</code> is not the same as <code>Hello_There</code> or <code>HELLO_THERE</code>.</para>

    <para>The following are examples of valid Qore identifiers:</para>

    <table frame='all'><title>Examples of Valid Qore Identifiers</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <thead>
	<row>
	  <entry><para>Identifier</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para><code>i</code></para></entry>
	  <entry><para>Simple one-character identifier</para></entry>
	</row>
	<row>
	  <entry><para><code>foo21</code></para></entry>
	  <entry><para>Identifier with number</para></entry>
	</row>
	<row>
	  <entry><para><code>this_is_a_long_identifier</code></para></entry>
	  <entry><para>Long identifier with underline characters</para></entry>
	</row>
	<row>
	  <entry><para><code>Total_318</code></para></entry>
	  <entry><para>Identifier with underline and number</para></entry>
	</row>
	<row>
	  <entry><para><code>AVeryBigNumber</code></para></entry>
	  <entry><para>Mixed case identifier name</para></entry>
	</row>
	<row>
	  <entry><para><code>CAPS</code></para></entry>
	  <entry><para>Identifier in all capital letters</para></entry>
	</row>
	
      </tbody>
    </tgroup>
    </table>  
    
    <para>The following are invalid identifiers:</para>
    
    <table frame='all'><title>Examples of Invalid Qore Identifiers</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Identifier</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para><code>1a</code></para></entry>
	  <entry><para>Does not start with an alphabetic character</para></entry>
	</row>
	<row>
	  <entry><para><code>this-and-that</code></para></entry>
	  <entry><para>Contains "-" characters</para></entry>
	</row>
	<row>
	  <entry><para><code>Start#10</code></para></entry>
	  <entry><para>Contains "#" character</para></entry>
	</row>
      </tbody>
    </tgroup>  
    </table>
    
  </sect1>
  <sect1 id="Comments">
    <title>Comments</title>

    <para>Comments are allowed in Qore scripts; line comments are preceded by a hash "#", and block comments are made C-style, ex:</para>

    <programlisting># this is a line comment
/* 
   this is a block comment 
*/</programlisting>
    
    <para>For line comments, all text following a hash until the end-of-line character "\n" is considered a part of the comment.</para>

    <para>For block comments, all text between the /* and */ is ignored by the parser.</para>

<para>Here is an example Qore script containing comments:</para>

<programlisting>#!/usr/bin/qore
#
# these are line comments
# another line comment

/*
   --- this text is in block comments
   print("hello"); &lt;- this won't get executed 
   --- because it's in the block comment
*/</programlisting>

  </sect1>
  <sect1 id="Variables">
    <title>Variables</title>

    <para>Variables are Qore identifiers prefixed by a "$" sign, similar to Perl. The data type of variables does not have to be declared in advance, and variable types are assigned and changed automatically as appropriate in the context of the operations being performed on them or the values being assigned. Any Qore variable can hold any Qore data type including container types (lists, hashes, or objects).</para>

    <para>A few variables are set by the Qore language during the execution of Qore programs. These are normal variables that can be reassigned to other values by the user if necessary.</para>

    <table id="Special_Qore_Variables">
      <title>Special Qore Variables</title>
      <tgroup cols='4' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Variable</para></entry>
	    <entry><para>Type</para></entry>
	    <entry><para>Data Type</para></entry>
	    <entry><para>Explanation</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><code>$argv</code></para></entry>
	    <entry><para>Local</para></entry>
	    <entry><para>List</para></entry>
	    <entry><para>automatically assigned local variable containing the list of subroutine or method arguments that were not assigned to parameter variables (see section <link linkend='Subroutines'>Subroutines</link> for more information)</para></entry>
	  </row>
	  <row>
	    <entry><para><code>$ARGV</code></para></entry>
	    <entry><para>Global</para></entry>
	    <entry><para>List</para></entry>
	    <entry><para>script command-line arguments (use the <link linkend='Qore::GetOpt_Class'>GetOpt Class</link> to parse command-line arguments)</para></entry>
	  </row>
	  <row>
	    <entry><para><code>$QORE_ARGV</code></para></entry>
	    <entry><para>Global</para></entry>
	    <entry><para>List</para></entry>
	    <entry><para>complete qore command-line arguments</para></entry>
	  </row>
	  <row>
	    <entry><para><code>$ENV</code></para></entry>
	    <entry><para>Global</para></entry>
	    <entry><para>Hash</para></entry>
	    <entry><para>UNIX program environment</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <note><para><code>$STDERR</code> and <code>$STDOUT</code> have been removed from Qore.  Use the <link linkend="Qore_IO_Constants">I/O constants</link> <command>stderr</command>, <command>stdout</command>, and <command>stdin</command> constants of the <link linkend='Qore_File_Class'>File Class</link> instead.</para></note>

<sect2 id="Lexical_Scope">
<title>Lexical Scope</title>

<para>Variables not in a parameter list automatically have global scope unless the first reference is prefixed with <command>my</command>.  Variable names in a parameter list are always local to their associated subroutine, method, or catch block. Global variables can be explicitly declared with <command>our</command>.  The <command>our</command> keyword is required if the parse option <code>PO_REQUIRE_OUR</code> (<code>-O</code> or <code>--require-our</code> command-line option) is set for the parent program.  See the section on <link linkend="Parse_Options">Parse Options</link> for more information.</para>

<para>Local variables are not shared between threads, however global variables are.  See <link linkend='Threading'>Threading</link> for more information.</para>

<para>For example (in the following script, the <command>our</command> keyword is optional):</para>

<programlisting>#!/usr/bin/qore
#
# variable scoping example

<command>our</command> $a = 1;        # this is a global variable
<command>our</command> ($b, $c, $d);  # list of global variables

<command>if</command> ($a == 1)
{
    <command>my</command> $a = 2; 
    <command>my</command> ($b, $c);
    # $a, $b, and $c are local variables, 
    # the use of which will not affect the 
    # global variables of the same name
    print("local a = $a\n"); 
}

print("global a = $a\n"); </programlisting>

<para>The first print() statement will output:</para>

<programlisting>local a = 2</programlisting>

<para>The second print() statement will output:</para>

<programlisting>global a = 1</programlisting>

</sect2>
</sect1>

<sect1 id="Basic_Data_Types">
<title>Basic Data Types</title>

<para>The following are the basic data types in Qore:</para>

<table><title>Basic data types</title>
<tgroup cols='4' align='left' colsep='1' rowsep='1'>

  <thead>
  <row>
    <entry><para>Type</para></entry>
    <entry><para>Description</para></entry>
    <entry><para>Example</para></entry>
    <entry><para>Default Value</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para><link linkend="Boolean">Boolean</link></para></entry>
    <entry><para>True or False value</para></entry>
    <entry><programlisting>True</programlisting></entry>
    <entry><para>False</para></entry>
  </row>
  <row>
    <entry><para><link linkend="String">String</link></para></entry>
    <entry><para>A sequence of ASCII characters</para></entry>
    <entry><programlisting>"string"</programlisting></entry>
    <entry><para>Empty string</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Integer">Integer</link></para></entry>
    <entry><para>A 64-bit signed integer</para></entry>
    <entry><programlisting>1</programlisting></entry>
    <entry><para>0</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Float">Float</link></para></entry>
    <entry><para>A double-precision floating-point number</para></entry>
    <entry><programlisting>1.00023</programlisting></entry>
    <entry><para>0.0</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Date">Date</link></para></entry>
    <entry><para>A date with an optional time component, with resolution to the second.</para></entry>
    <entry><programlisting>2005-07-20</programlisting></entry>
    <entry><para>0000-00-00 00:00:00</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Binary">Binary</link></para></entry>
    <entry><para>An opaque binary object</para></entry>
    <entry><programlisting>n/a</programlisting></entry>
    <entry><para>an empty object of size 0</para></entry>
  </row>
  <row>
    <entry><para><link linkend="NULL">NULL</link></para></entry>
    <entry><para>Corresponds to a NULL value in a database query (not equivalent to NOTHING)</para></entry>
    <entry><programlisting><command>NULL</command></programlisting></entry>
    <entry><para>n/a</para></entry>
  </row>
  <row>
    <entry><para><link linkend="NOTHING">NOTHING</link></para></entry>
    <entry><para>Represents the state of a variable having no value or function returning no value (not equivalent to NULL)</para></entry>
    <entry><programlisting><command>NOTHING</command></programlisting></entry>
    <entry><para>n/a</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<sect2 id="Boolean">
  <title>Boolean</title>
  <para>The Boolean type can have two values, True and False. When converting other types to a Boolean, any value that converts to a non-zero integer will be evaluated as True. Otherwise the result of the conversion will be False.</para>
</sect2>

<sect2 id="String">
  <title>String</title>
  <para>String values are specified with text between double or single quotes. Text between double quotes is subject to interpretation of escape characters. Please see <link linkend="String_Formatting">String Formatting</link> for more information.</para>

  <para>Strings are assumed by default to have the encoding given by the <code>QORE_CHARSET</code> or the <code>LANG</code> environment variable. If neither of these variables is set, then all strings will be assumed to have UTF-8 encoding.</para>

  <para>For detailed information on Qore character set handling, please see section <link linkend="Qore_Strings_and_Character_Set_Encoding">Qore Strings and Character Set Encoding</link>.</para>
</sect2>

<sect2 id="Integer">
  <title>Integer</title>
  <para>Qore integers are 64-bit signed integers.</para>
</sect2>

<sect2 id="Float">
  <title>Float</title>
  <para>Qore floats are double precision floating-point numbers.</para>
</sect2>

<sect2 id="Date">
  <title>Date</title>
  <para>Qore dates have a time component and can be either absolute or relative. Absolute dates are normal dates, such as January 1, 2005 10:35:00 and can be specified with a special syntax as follows:</para>

  <para><code>&lt;4d-year&gt;-&lt;2d-month&gt;-&lt;2d-day&gt;-&lt;2d-hour&gt;:&lt;2d-minute&gt;:&lt;2d-second&gt;</code></para>

  <para>or, for just the date, without a time component:</para>

  <para><code>&lt;4d-year&gt;-&lt;2d-month&gt;-&lt;2d-day&gt;</code></para>

  <para>or, for just the time, without a date component (note that in this case the date component will be set to Jan 1, 1970, in order for time arithmetic to function properly):</para>

  <para><code>&lt;2d-hour&gt;:&lt;2d-minute&gt;:&lt;2d-second&gt;</code></para>

  <para>For example:</para>

  <para><code>2005-03-29-18:12:25</code> represents: March 29, 2005 6:12:25 pm</para>
  <para><code>0512-01-01-01:49:59</code> represents: January 1, 512 1:49:59 am</para>

  <para><code>2005-03-29</code> represents: March 29, 2005 00:00:00</para>
  <para><code>18:35:26</code> represents: 6:35:26 pm</para>

  <para>The year must be a four-digit number, and all other values must be two-digit numbers.  Pad the numbers with leading zeros if the numbers are smaller than the required number of spaces.  The hour component must be in 24-hour time format. Except for the month and day values, all other values start with 0 (hour = 00 - 23, minute and second: 00 - 59).  Any deviation from this format will cause a parse exception.</para>

  <para>Relative dates are specified as follows:</para>

  <para><code>&lt;integer&gt;&lt;date component specifier&gt;</code></para>

  <table><title>Date Specifiers For Relative Dates</title>
  <tgroup cols='4' align='left' colsep='1' rowsep='1'>
    
    <thead>
      <row>
	<entry><para>Component</para></entry>
	<entry><para>Meaning</para></entry>
	<entry><para>Example</para></entry>
	<entry><para>Description</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>Y</para></entry>
	<entry><para>Years</para></entry>
	<entry><programlisting>2Y</programlisting></entry>
	<entry><para>2 Years</para></entry>
      </row>
      <row>
	<entry><para>M</para></entry>
	<entry><para>Months</para></entry>
	<entry><programlisting>3M</programlisting></entry>
	<entry><para>3 Months</para></entry>
      </row>
      <row>
	<entry><para>D</para></entry>
	<entry><para>Days</para></entry>
	<entry><programlisting>10D</programlisting></entry>
	<entry><para>10 Days</para></entry>
      </row>
      <row>
	<entry><para>h</para></entry>
	<entry><para>Hours</para></entry>
	<entry><programlisting>15h</programlisting></entry>
	<entry><para>15 hours</para></entry>
      </row>
      <row>
	<entry><para>m</para></entry>
	<entry><para>Minutes</para></entry>
	<entry><programlisting>25m</programlisting></entry>
	<entry><para>25 minutes</para></entry>
      </row>
      <row>
	<entry><para>s</para></entry>
	<entry><para>Seconds</para></entry>
	<entry><programlisting>19s</programlisting></entry>
	<entry><para>19 seconds</para></entry>
      </row>
    </tbody>
  </tgroup>
</table>

<para>Relative dates are normally used for date addition and subtraction.  See section <link linkend='Date_Arithmetic'>Date Arithmetic</link> for more information.</para>

<note>
  <para>Currently there is no time-zone component in Qore dates.  Timezone support may be added in future versions of the Qore 
language, either by an addition to this data type, or by adding another date type including a time zone component.</para>
</note>

</sect2>
<sect2 id="Binary">
  <title>Binary</title>

  <para>The binary data type is used to hold binary arbitrary binary data. Internally 
  it is represented by a memory pointer and a size indicator. </para>

  <para>Currently this data can be manipulated by being written and read from File, Socket, and Datasource objects, or converted and parsed to/from base64 encoded strings using the <link linkend="makeBase64String">makeBase64String()</link> and <link linkend="parseBase64String">parseBase64String()</link> functions.</para>

  <para>Binary objects can be read from a File object using the <link linkend="Qore_File_readBinary">File::readBinary()</link> method and can be written using the <link linkend="Qore_File_write">File::write()</link> method.  Please see the <link linkend='Qore_File_Class'>File Class</link> for more information.</para>
  
  <para>Binary objects can be read from a Socket object using the <link linkend="Qore_Socket_recvBinary">Socket::recvBinary()</link> method and can be written using the <link linkend="Qore_Socket_send">Socket::send()</link> method. Please see the <link linkend="Qore_Socket_Class">Socket Class</link> for more information.</para>

  <para>The <link linkend="Qore::SQL::Datasource_Class">Datasource Class</link> can also be used to read and write Binary objects as BLOBs.</para>

</sect2>

<sect2 id="NULL">
  <title>NULL</title>
  <para>This data type represents an SQL NULL value.  Note that <command>NULL</command> is not equivalent to <command>NOTHING</command>.</para>
</sect2>

<sect2 id="NOTHING">
  <title>NOTHING</title>
  <para>This special data type represents no value.</para>
  <note><para>The <command>exists</command> operator will return False when given <command>NOTHING</command> as an argument.</para></note>
</sect2>

<sect2 id="Conversions">
  <title>Conversions</title>
  <para>Boolean, string, integer, date, and floating point data types can be freely converted from one type to the other, although data loss is possible depending on the conversion.</para>

  <para>The special types <command>NULL</command> and <command>NOTHING</command> are not equivalent and cannot be converted to or from any other type.</para>

  <para>When date types are converted to/from strings, integers, and floating-point numbers, the following format must be used: "YYYYMMDDHHmmSS".</para>

  <para>When an expression requires a certain data type and the source data type cannot be converted to the desired data type, the default value for the desired data type will be used.  The default values are given <link linkend="Basic_Data_Types">here</link>.</para>
</sect2>

</sect1>

<sect1 id="Container_Data_Types">
  <title>Container Data Types</title>

  <para>Qore supports three types of container types: lists, hashes (associative arrays), and objects (see <link linkend="Objects">Objects</link> and <link linkend="Classes">Classes</link> for more information on objects and classes).  These container types can be combined to make arbitrarily complex data structures.</para>

  <para>The data type of any element can be any basic type or another aggregate type.  The types do not have to be uniform in one container structure.</para>

  <sect2 id="Lists">
    <title>Lists</title>

    <para>Lists (or arrays) are simply ordered containers of values.  A list element can be any Qore type (even another list, hash, or object).</para>

    <para>Lists are specified by giving expressions separated by commas as follows:</para>

    <programlisting>$list = <replaceable>expression</replaceable>, <replaceable>expression</replaceable> [, <replaceable>expression</replaceable> ...];</programlisting>

    <para>Here is a concrete example:</para>

    <programlisting>$list = 1, 2, "three", 4.0, 5, 6;</programlisting>

    <note>
      <para>Note that trailing commas can be left on the end of a list (or a hash, for that matter).  This makes it easier to comment-out the last element of a multi-line list without having to worry about removing the trailing comma.</para>
    </note>

    <para>List elements are dereferenced using square brackets: <link linkend='List_Dereference_Operator'>"[" and "]"</link>. The first element in a list has index zero.</para>

    <programlisting>$element3 = $list[2];</programlisting>

    <para>The following operators perform special processing on lists: <link linkend="Elements_Operator"><command>elements</command></link>, <link linkend="Shift_Operator"><command>shift</command></link>, <link linkend="Unshift_Operator"><command>unshift</command></link>, <link linkend="Push_Operator"><command>push</command></link>, <link linkend="Pop_Operator"><command>pop</command></link>, <link linkend="Splice_Operator"><command>splice</command></link>, <link linkend='List_Dereference_Operator'>[]</link>, <link linkend='Plus_Operator'>+</link>, and <link linkend='Plus_Equals_Operator'>+=</link>.</para>

  </sect2>
  <sect2 id="Hashes">
    <title>Hashes</title>

    <para>Hashes are containers that associate values to a string key.</para>

    <note><para>Note that Qore hashes preserve the insertion order in order to be able to guarantee the order of keys when hashes are serialized to XML strings, therefore the <command>keys</command> operator will always return the hash keys in insertion/creation order.</para></note>
    
    <para>Hashes are specified using the following syntax:</para>
    
    <programlisting>$hash = ( "key1" : <replaceable>expression</replaceable>,
          "key2" : <replaceable>expression</replaceable>,
	  ... );</programlisting>

    <para>Here is a concrete example:</para>

    <programlisting>$hash = ( "apple" : 1 + 1,
          "pear"  : "good" );</programlisting>

    <para>Hashes are dereferenced in one of two ways, either using curly brackets: "{" and "}", where any valid Qore expression can be used, or using the dot "." hash member dereferencing operator, where only literal strings can be used.</para>

    <programlisting>$element3 = $hash{"pe" + "ar"};</programlisting>

    <para>Is equivalent to:</para>

    <programlisting>$element3 = $hash.pear;</programlisting>

    <para>and:</para>

    <programlisting>$element3 = $hash."pear";</programlisting>

    <para>A literal string after the dot "." hash member dereferencing operator must be a valid Qore identifier; therefore if you want to use a hash key that's not a valid identifier, enclose the string in quotes.</para>
    
    <para>If you want to use the result of an expression to dereference the hash, then the curly bracket syntax must be used.</para>
    
    <para>Note that hash keys can also be given by constants (as long as the constant resolved to a string).</para>
    
  </sect2>
  <sect2 id="Objects">
    <title>Objects</title>

    <para>Qore objects are instantiations of a Qore class.  They have members (like a hash - values associated to string keys), and methods.  The Qore class defition specifies the methods that run on objects of that class, and any private members.  Qore classes are declared with a special syntax, and objects are instantiated using the <command>new</command> operator as follows.</para>

    <programlisting><replaceable>lvalue</replaceable> = <command>new</command> <replaceable>class_identifier</replaceable>([<replaceable>argument list</replaceable>])</programlisting>

    <para>Objects have named data members that are referenced like hash elements, although this behavior can be modified for objects using the memberGate() method.  Object members are accessed by appending a dot '.' and the member name to the object reference as follows:</para>

<programlisting><replaceable>object_reference.member_name</replaceable></programlisting>

<para>Object methods are called by appending a dot '.' and a method name to the object reference as follows:</para>

<programlisting><replaceable>object_reference</replaceable>.<replaceable>method_name</replaceable>([<replaceable>argument_list</replaceable>])</programlisting>

<para>The object references above are normally variable references holding an object, but could be any expression that returns an object, such as a new expression or even a subroutine call.</para>

<note>
<para>Objects are always passed by reference, like in Java.  Objects can only be explicitly copied; otherwise any object instantiated with the <command>new</command> operator will remain unique until deleted or explicitly copied.  An explicit copy is made with the copy constructor, and does not guarantee an exact copy of the source object (it depends on the definition of the copy method for the class in question).</para>
</note>

<para>Objects exist until they go out of scope, are explicitly deleted, or their last thread exits.  For detailed information, see the section <link linkend='Classes'>Classes</link> on Qore classes.</para>
</sect2>
</sect1>

<sect1 id="Qore_Strings_and_Character_Set_Encoding">
<title>Qore Strings and Character Set Encoding</title>

<para>The Qore language is character-set aware.  All strings are assumed to have the default character set, unless the program explicitly specified another character set for certain objects and operations.  Every Qore string has a character set ID attached to it, so, when another character set is required, the Qore language will attempt to do a character set translation.</para>

<para>Qore supports character sets that are backwards compatible with 7-bit ASCII.  This includes all ISO-8859-* character sets, UTF-8, KOIR-8, KOIU-8, and KOI7, among others.</para>

<para>The default Qore character set is determined by environment variables.</para>

<para>First, the <code>QORE_CHARSET</code> environment variable is checked. If it is set, then this character set will be the default character set for the process.  If not, then the <code>LANG</code> environment variable is checked. If a character set is specified in the <code>LANG</code> environment variable, then it will be used as the default character set.  Otherwise, if no character set can be derived from the environment, UTF-8 is assumed.</para>

<para>Character set encodings are automatically converted by the Qore language when necessary.  Encoding conversion errors will cause a Qore Exception to be thrown.  The character set encoding conversions supported by Qore depend on the Operating System's iconv library function.</para>

<para>Character set encodings can be explicitly performed with the <link linkend="convert_encoding">convert_encoding()</link> function, and the encoding attached to a string can be checked with the <link linkend="get_encoding">get_encoding()</link> function. </para>

<para>The TibcoAdapter class will automatically convert all strings to UTF-8 encoding if necessary before transmitting any messages, as required by the TIBCO SDK. See section <link linkend='Qore_TibcoAdapter_Class'>TibcoAdapter Class</link> for more information.</para>

<para>Datasource objects will translate character set encoding to the encoding required by the database if necessary as well (this is actually the responsibility of the DBI driver for the database in question).  See section <link linkend='Qore::SQL::Datasource_Class'>Datasource Class</link> for more information.</para>

<para>Socket objects will translate character set encoding to encoding specified for the Socket, if any has been set.  See section <link linkend='Qore_Socket_Class'>Socket Class</link> for more information.</para>

<para>File objects will also automatically convert any string to the encoding specified for the File, if any has been set.  See section <link linkend='Qore_File_Class'>File Class</link> for more information.</para>

<para>Additionally you can serialize a Qore hash to an XML string and specify the character set encoding to use. If the target encoding is different than the source encoding conversions are automatically performed. See section <link linkend="XML_Integration">XML Integration</link> for more information about XML handling.</para>

</sect1>

  <sect1 id="Expressions">
    <title>Expressions</title>

    <para>An expression can be any of the following (note that expressions are also recursively defined):</para>
    <table>
      <title>Expressions</title>
      <tgroup cols='4' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Type</para></entry>
	    <entry><para>Description</para></entry>
	    <entry>
	    <para>Examples</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para>An immediate value</para></entry>
	    <entry><para>Qore values that can be expressed directly (see section <link linkend="Basic_Data_Types">Basic Data Types</link> for more information)</para></entry>
	    <entry>
	      <programlisting>True
152
1.2
"a string"
2005-10-27
<command>NULL</command>
<command>NOTHING</command>
("key" : $val)
1, 2.0, "three"</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A variable reference</para></entry>
	    <entry><para>Qore variables (see <link linkend="Variables">Variables</link> for more information)</para></entry>
	    <entry>
	      <programlisting>$var</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A variable or variable expression assignment</para></entry>
	    <entry><para>Assigns a value to a lvalue (see <link linkend="Assignment_Operator">Assignment Operator</link> for more information)</para></entry>
	    <entry>
	      <programlisting>$var = 1
($a, $b, $c, $date) = (1, "two", 3.3, 2005-10-28)</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A subroutine/function call</para></entry>
	    <entry><para>Qore subroutine calls (see <link linkend="Subroutines">Subroutines</link> for more information)</para></entry>
	    <entry>
	      <programlisting>calculate($var1, $var2, "string", 4)</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A method call</para></entry>
	    <entry><para>Qore object method calls (see <link linkend="Objects">Objects</link> for more information)</para></entry>
	    <entry><programlisting>$object.method("argument")</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>Expressions with operators</para></entry>
	    <entry><para>Use of Qore operators (see <link linkend='Operators'>Operators</link> for more information)</para></entry>
	    <entry>
	      <programlisting>1 + 2
$a || $b
<command>background</command> my_function()</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>An expression in parentheses</para></entry>
	    <entry><para>Use of parentheses for clarity or to specify evaluation precedence.</para></entry>
	    <entry>
	      <programlisting>(1 + 2)
(2 * (3 + 1))</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A list</para></entry>
	    <entry><para>a list of values (see <link linkend="Lists">Lists</link> for more information)</para></entry>
	    <entry>
	    <programlisting>1, 2, 3, "four", 5.0</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>A hash</para></entry>
	    <entry><para>a hash (associative/keyed array) value container (see <link linkend="Hashes">Hashes</link> for more information)</para></entry>
	    <entry>
	      <programlisting>( "key1" : 1, "key2" : "two" )</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A <command>find</command> expression</para></entry>
	    <entry><para>Finds a value or values in a hash of lists, such as returned by the <link linkend="Qore::SQL::Datasource::select">Datasource::select() method</link> (see <link linkend="find_Expressions">find expressions</link> for more information)</para></entry>
	    <entry>
	      <programlisting><command>find</command> %name, %id <command>in</command> $data <command>where</command> (%name =~ /Smith/);</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A context identifier (<code>%column</code>)</para></entry>
	    <entry><para>A contextual reference to the value of a key of a complex data structure within the current row being iterated by a <link linkend="context_Statements"><command>context</command></link>, <link linkend="summarize_Statements"><command>summarize</command></link>, <link linkend="subcontext_Statements"><command>subcontext</command></link> statement, or a  <link linkend="find_Expressions"><command>find</command> expression</link>.</para></entry>
	    <entry>
	      <programlisting>%name</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A context row identifier (<code>%%</code>)</para></entry>
	    <entry><para>A contextual reference to the current row of complex data structure being iterated by a <link linkend="context_Statements"><command>context</command></link>, <link linkend="summarize_Statements"><command>summarize</command></link>, <link linkend="subcontext_Statements"><command>subcontext</command></link> statement, or a <link linkend="find_Expressions"><command>find</command> expression</link>.  This expression will return a hash of the current row.</para></entry>
	    <entry>
	      <programlisting>%%</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A backquote expression</para></entry>
	    <entry><para>Executes a UNIX process and returns the stdout as a string</para></entry>
	    <entry><programlisting>'ls -l'</programlisting></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
    
    <sect2 id="find_Expressions">
      <title>find Expressions</title>
      
      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>The <command>find</command> expression can be used to quickly find data in a hash of lists (such as a query result set returned by the <link linkend="Qore::SQL::Datasource::select">Datasource::select()</link> method).  The <command>find</command> expression will loop through a data structure based until an expression becomes True, and then it will evaluate and return a result expression.  In each part of the <command>find</command>, column names can be referred to by preceding the name with a '%" character (as with <link linkend="context_Statements">context statements</link>).</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <para>
	      <programlisting><command>find</command> <replaceable>result_expression</replaceable> <command>in</command> <replaceable>data_expression</replaceable> <command>where</command> ( <replaceable>where_expression</replaceable> )</programlisting>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para><replaceable>result_expression</replaceable></para>
	    <para>This expression will be evaluated and returned when the <replaceable>where_expression</replaceable> evaluates to True.</para>

	    <para><replaceable>data_expression</replaceable></para>
	    <para>This expression must evaluate to a hash of lists, so that the internal context can be set up for the <command>find</command> loop.</para>
	    
	    <para><replaceable>where_expression</replaceable></para>
	    <para>This expression will be evaluated for each row in the <replaceable>data_expression</replaceable>.  When it returns True, the <replaceable>result_expression</replaceable> will be evaulated and returned.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Example</term>
	  <listitem>
	    <programlisting>$rlist = <command>find</command> %name, %id <command>in</command> $data <command>where</command> (%name =~ /Smith/);</programlisting>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 id="Operators">
    <title>Operators</title>

    <para>The following table lists all Qore operators in order of precedence, starting with the highest precedence. The lower the precedence number, the higher the precedence, therefore the operators with precedence level 1 ("{}", "[]", ".") have the highest precedence of all Qore operators.  The precedence levels in Qore are roughly equal to the precedence levels of C language operators (however note the important difference with the , operator as noted below). To explicitly specify the precedence for expression evaluation, use parentheses ().</para>

<table><title>Operators</title>
<tgroup cols='4' align='left' colsep='1' rowsep='1'>

  <thead>
  <row>
    <entry><para>Operator</para></entry>
    <entry><para>Prec.</para></entry>
    <entry><para>Description</para></entry>
    <entry><para>Example</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>``</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='Backquote_Operator'>backquote/backtick operator</link></para></entry>
    <entry><programlisting>`ls -l`</programlisting></entry>
  </row>
  <row>
    <entry><para>{}</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='Hash_Element_Expression_Dereference_Operator'>hash element or object member expression dereference operator</link></para></entry>
    <entry><programlisting>$hash{"na" + "me"}</programlisting></entry>
  </row>
  <row>
    <entry><para>.</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='Hash_Element_Literal_Dereference_Operator'>hash element or object member literal dereference operator</link></para></entry>
    <entry>
      <programlisting>$hash.name
$obj.method()</programlisting>
    </entry>
  </row>
  <row>
    <entry><para>[]</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='List_Dereference_Operator'>list element dereference operator</link></para></entry>
    <entry><programlisting>$list[1]</programlisting></entry>
  </row>
  <row>
    <entry><para>++</para></entry>
    <entry><para>2</para></entry>
    <entry><para><link linkend='Pre_Increment_Operator'>pre-increment operator</link>, <link linkend='Post_Increment_Operator'>post-increment operator</link></para></entry>
    <entry><programlisting>$a++</programlisting></entry>
  </row>
  <row>
    <entry><para>--</para></entry>
    <entry><para>2</para></entry>
    <entry><para><link linkend='Pre_Increment_Operator'>pre-increment operator</link>, <link linkend='Post_Increment_Operator'>post-increment operator</link></para></entry>
    <entry><programlisting>$a--</programlisting></entry>
  </row>
  <row>
    <entry><para><command>new</command></para></entry>
    <entry><para>3</para></entry>
    <entry><para><link linkend='New_Object_Operator'>class instantiation/new object operator</link></para></entry>
    <entry><programlisting><command>new</command> Socket()</programlisting></entry>
  </row>
  <row>
    <entry><para><command>background</command></para></entry>
    <entry><para>3</para></entry>
    <entry><para><link linkend='Background_Operator'>background/thread creation operator</link></para></entry>
    <entry><programlisting><command>background</command> mainThread()</programlisting></entry>
  </row>
  <row>
    <entry><para>!</para></entry>
    <entry><para>4</para></entry>
    <entry><para><link linkend='Logical_Not_Operator'>logical negation operator</link></para></entry>
    <entry><programlisting><command>if</command> (!($a &gt; 10)) ...</programlisting></entry>
  </row>
  <row>
    <entry><para>~</para></entry>
    <entry><para>5</para></entry>
    <entry><para><link linkend='Binary_Not_Operator'>binary not/bit inversion operator</link></para></entry>
    <entry><programlisting>$var = ~$var</programlisting></entry>
  </row>
  <row>
    <entry><para>- (unary minus)</para></entry>
    <entry><para>6</para></entry>
    <entry><para><link linkend='Unary_Minus_Operator'>unary minus operator</link></para></entry>
    <entry><programlisting>$var = -$var</programlisting></entry>
  </row>
  <row>
    <entry><para><command>shift</command></para></entry>
    <entry><para>7</para></entry>
    <entry><para><link linkend='Shift_Operator'>shift list element operator</link></para></entry>
    <entry><programlisting><command>shift</command> $list</programlisting></entry>
  </row>
  <row>
    <entry><para><command>pop</command></para></entry>
    <entry><para>7</para></entry>
    <entry><para><link linkend='Pop_Operator'>pop list element operator</link></para></entry>
    <entry><programlisting><command>pop</command> $list</programlisting></entry>
  </row>
  <row>
    <entry><para><command>elements</command></para></entry>
    <entry><para>8</para></entry>
    <entry><para><link linkend='Elements_Operator'>number of elements list/hash operator</link></para></entry>
    <entry><programlisting><command>elements</command> $list</programlisting></entry>
  </row>
  <row>
    <entry><para><command>keys</command></para></entry>
    <entry><para>8</para></entry>
    <entry><para><link linkend='Keys_Operator'>hash key list operator</link></para></entry>
    <entry><programlisting><command>keys</command> $hash</programlisting></entry>
  </row>
  <row>
    <entry><para>*</para></entry>
    <entry><para>9</para></entry>
    <entry><para><link linkend='Multiply_Operator'>arithmetic multiplication operator</link></para></entry>
    <entry><programlisting>$var = $a * 10</programlisting></entry>
  </row>
  <row>
    <entry><para>/</para></entry>
    <entry><para>9</para></entry>
    <entry><para><link linkend='Divide_Operator'>arithmetic division operator</link></para></entry>
    <entry><programlisting>$var = $a / 10</programlisting></entry>
  </row>
  <row>
    <entry><para>%</para></entry>
    <entry><para>10</para></entry>
    <entry><para><link linkend='Modula_Operator'>arithmetic modula operator</link></para></entry>
    <entry><programlisting>$var = $a % 10</programlisting></entry>
  </row>
  <row>
    <entry><para>+</para></entry>
    <entry><para>11</para></entry>
    <entry><para><link linkend='Plus_Operator'>plus operator: string, list, and hash concatenation, integer and float addition</link></para></entry>
    <entry><programlisting>$a + 10
"hello" + "there"
$list + "new value"
$hash + ( "newkey" : 100 )</programlisting>
    </entry>
  </row>
  <row>
    <entry><para>-</para></entry>
    <entry><para>11</para></entry>
    <entry><para><link linkend='Minus_Operator'>minus operator, arithmetic subtraction</link></para></entry>
    <entry><programlisting>$a - 10</programlisting></entry>
  </row>
  <row>
    <entry><para>&gt;&gt;</para></entry>
    <entry><para>12</para></entry>
    <entry><para><link linkend='Shift_Right_Operator'>bitwise shift right operator</link></para></entry>
    <entry><programlisting>0xff00 &gt;&gt; 8</programlisting></entry>
  </row>
  <row>
    <entry><para>&lt;&lt;</para></entry>
    <entry><para>12</para></entry>
    <entry><para><link linkend='Shift_Left_Operator'>bitwise shift left operator</link></para></entry>
    <entry><programlisting>0xff00 &lt;&lt; 8</programlisting></entry>
  </row>
  <row>
    <entry><para><command>exists</command></para></entry>
    <entry><para>13</para></entry>
    <entry><para><link linkend='Exists_Operator'>exists value operator</link></para></entry>
    <entry><programlisting><command>exists</command> $var</programlisting></entry>
  </row>
  <row>
    <entry><para>&lt;</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Less_Than_Operator'>Logical less than operator</link></para></entry>
    <entry><programlisting>$a &lt; 10</programlisting></entry>
  </row>
  <row>
    <entry><para>&gt;</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Greater_Than_Operator'>Logical greater than operator</link></para></entry>
    <entry><programlisting>$a &gt; 10</programlisting></entry>
  </row>
  <row>
    <entry><para>==</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Equals_Operator'>Logical equality operator</link></para></entry>
    <entry><programlisting>$a == 10</programlisting></entry>
  </row>
  <row>
    <entry><para>!=</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Not_Equals_Operator'>logical inequality operator</link></para></entry>
    <entry><programlisting>$a != 10</programlisting></entry>
  </row>
  <row>
    <entry><para>&lt;=</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Less_Than_Or_Equals_Operator'>Logical less then or equals operator</link></para></entry>
    <entry><programlisting>$a &lt;= 10</programlisting></entry>
  </row>
  <row>
    <entry><para>&gt;=</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Greater_Than_Or_Equals_Operator'>logical greater than or equals operator</link></para></entry>
    <entry><programlisting>$a &gt;= 10</programlisting></entry>
  </row>
  <row>
    <entry><para>&lt;=&gt;</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Comparison_Operator'>logical comparison operator</link></para></entry>
    <entry><programlisting>$a &lt;=&gt; $b</programlisting></entry>
  </row>
  <row>
    <entry><para>===</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Absolute_Equals_Operator'>absolute logical equality operator</link></para></entry>
    <entry><programlisting>$a === 10</programlisting></entry>
  </row>
  <row>
    <entry><para>!==</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Absolute_Not_Equals_Operator'>absolute logical inequality operator</link></para></entry>
    <entry><programlisting>$a !== 10</programlisting></entry>
  </row>
  <row>
    <entry><para>=~</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Regular_Expression_Match_Operator'>regular expression match operator</link></para></entry>
    <entry><programlisting>$a =~ /text/</programlisting></entry>
  </row>
  <row>
    <entry><para>!~</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Regular_Expression_No_Match_Operator'>regular expression no match operator</link></para></entry>
    <entry><programlisting>$a !~ /text/</programlisting></entry>
  </row>
 <row>
    <entry><para>=~ s</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Regular_Expression_Substitution_Operator'>regular expression substitution operator</link></para></entry>
    <entry><programlisting>$a =~ s/text/text/</programlisting></entry>
  </row>
  <row>
    <entry><para>&amp;</para></entry>
    <entry><para>15</para></entry>
    <entry><para><link linkend='Binary_And_Operator'>bitwise AND operator</link></para></entry>
    <entry><programlisting>$a &amp; 0xff</programlisting></entry>
  </row>
  <row>
    <entry><para>|</para></entry>
    <entry><para>15</para></entry>
    <entry><para><link linkend='Binary_Or_Operator'>bitwise OR operator</link></para></entry>
    <entry><programlisting>$a | 0xff</programlisting></entry>
  </row>
  <row>
    <entry><para>^</para></entry>
    <entry><para>15</para></entry>
    <entry><para><link linkend='Binary_Xor_Operator'>bitwise XOR operator</link></para></entry>
    <entry><programlisting>$a ^ 0xff</programlisting></entry>
  </row>
  <row>
    <entry><para>&amp;&amp;</para></entry>
    <entry><para>16</para></entry>
    <entry><para><link linkend='Logical_And_Operator'>logical AND operator</link></para></entry>
    <entry><programlisting>($a = 1) &amp;&amp; ($b &lt; 10)</programlisting></entry>
  </row>
  <row>
    <entry><para>||</para></entry>
    <entry><para>16</para></entry>
    <entry><para><link linkend='Logical_Or_Operator'>logical OR operator</link></para></entry>
    <entry><programlisting>($a = 1) || ($b &lt; 10)</programlisting></entry>
  </row>
  <row>
    <entry><para>? :</para></entry>
    <entry><para>17</para></entry>
    <entry><para><link linkend='Conditional_Operator'>conditional operator</link></para></entry>
    <entry><programlisting>$a == 2 ? "yes" : "no"</programlisting></entry>
  </row>
  <row>
    <entry><para>,</para></entry>
    <entry><para>18</para></entry>
    <entry><para><link linkend='Comma_Operator'>comma operator</link></para></entry>
    <entry><programlisting>1, 2, 3, 4, 5</programlisting></entry>
  </row>
  <row>
    <entry><para><command>unshift</command></para></entry>
    <entry><para>19</para></entry>
    <entry><para><link linkend='Unshift_Operator'>unshift list element operator</link></para></entry>
    <entry><programlisting><command>unshift</command> $list, $val</programlisting></entry>
  </row>
  <row>
    <entry><para><command>push</command></para></entry>
    <entry><para>19</para></entry>
    <entry><para><link linkend='Push_Operator'>push list element operator</link></para></entry>
    <entry><programlisting><command>push</command> $list, $val</programlisting></entry>
  </row>
  <row>
    <entry><para><command>splice</command></para></entry>
    <entry><para>19</para></entry>
    <entry><para><link linkend='Splice_Operator'>splice list or string operator</link></para></entry>
    <entry><programlisting><command>splice</command> $list, 2, 2, (1, 2, 3)</programlisting></entry>
  </row>
  <row>
    <entry><para>=</para></entry>
    <entry><para>20</para></entry>
    <entry><para><link linkend='Assignment_Operator'>assignment operator</link></para></entry>
    <entry><programlisting>$var = 1</programlisting></entry>
  </row>
  <row>
    <entry><para>+=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Plus_Equals_Operator'>plus-equals (add-to) operator</link></para></entry>
    <entry><programlisting>$var += 5</programlisting></entry>
  </row>
  <row>
    <entry><para>-=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Minus_Equals_Operator'>minus-equals (subtract-from) operator</link></para></entry>
    <entry><programlisting>$var -= 5</programlisting></entry>
  </row>
  <row>
    <entry><para>&amp;=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='And_Equals_Operator'>and-equals operator</link></para></entry>
    <entry><programlisting>$var &amp;= 0x2000</programlisting></entry>
  </row>
  <row>
    <entry><para>|=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Or_Equals_Operator'>or-equals operator</link></para></entry>
    <entry><programlisting>$var |= 0x2000</programlisting></entry>
  </row>

</tbody>
</tgroup>
</table>

<note>
<para>All Qore operators perform thread-atomic actions with respect to the immediate arguments of the operator.  If the operators are used in a complex expression, the entire expression is not thread-atomic unless explicit user-level locking is used.  For example: $a += 5 is a thread-atomic action, but $a += $b-- is not atomic, but rather made up of two atomic actions.</para>
</note>

<note>
  <para>When an operator taking more than one argument 
  is used with arguments of different data types, Qore automatically converts one 
  or both data types to a data type supported by the operator in order to evaluate 
  the result, according to the precedence lists in the following section. That is; 
  when an operator operates on mixed types, the types listed first in the 
  following sections have precedence over types listed farther down in the lists. 
  The result type will always be equal to the final operation type after any 
  conversions due to type precedence per operator. If no type of either argument 
  matches a supported data type for the operator, both types will be converted to 
  the highest precedence data type for the operator and then the operator will 
  evaluate the result. For explicit type conversion, please see the 
  <link linkend="boolean">boolean()</link>, <link linkend="string">string()</link>, 
  <link linkend="date">date()</link>, <link linkend="int">int()</link>, 
  <link linkend="float">float()</link>, etc functions.</para>
</note>

<note>
  <para>The Qore comma ',' operator has a higher precendece than the '=' operator, meaning that a statement like $a = 1, 2, 3; is possible without parentheses.  However, it means that a statment like $a = func(1, 2, $b = 3, 4); will probably not do what you want (it use $b as the third argument which is assigned to the list (3, 4)); you must write $a = func(1, 2, ($b = 3), 4); to pass 4 arguments to the function func.</para>
</note>

<sect2 id="Backquote_Operator">
  <title>Backquote Operator (``)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Executes the shell command in a separate process and returns the stdout as a string.  To perform the same action using a Qore expression, see the <link linkend="backquote">backquote function</link>.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>`shell_command`</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$dirlisting = `ls -l`</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <informaltable>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>shell_command</replaceable></para></entry>
	  <entry><para>The shell command will be executed and the stdout is returned as a string.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </informaltable>

  <table>
    <title>Exceptions Thrown by ``</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>BACKQUOTE-ERROR</para></entry>
	  <entry><para>An error occurred in fork() or creating the output pipe.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
</sect2>

<sect2 id="Hash_Element_Expression_Dereference_Operator">
  <title>Hash Element or Object Member Expression Dereference Operator ({})</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Retrieves the value of hash key or object member by evaulating an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>container_expression{expression}</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>printf("%s\n", $hash{getName()});</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>


  <table><title>Arguments Processed by {}</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para><replaceable>container_expression</replaceable></para></entry>
	<entry><para>This expression must evaluate to a hash or an object. If not, then the operator returns no value.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>expression</replaceable></para></entry>
	<entry><para>This expression is evaluated and converted to a string if necessary. The value of the hash key corresponding to this string will be returned. If the key or member does not exist, then no value is returned.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>

  <table><title>Exceptions Thrown by {}</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>err</para></entry>
	<entry><para>desc</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>PRIVATE-MEMBER</para></entry>
	<entry><para>Attempt to access a private member outside the class.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Hash_Element_Literal_Dereference_Operator">
  <title>Hash Element or Object Member Literal Dereference Operator (.)</title>

    <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Retrieves the value of a hash key or object member using a literal identifier.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>container_expression.identifier</replaceable>
<replaceable>container_expression.method_identifier([arguments...])</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>printf("%s\n", $hash.name);</programlisting>
	<programlisting>$obj.method("argument");</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed by .</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para><replaceable>container_expression</replaceable></para></entry>
	  <entry><para>This expression must evaluate to a hash or an object. If not, then the operator returns no value.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>identifier</replaceable></para></entry>
	  <entry><para>The value of the hash key or object member corresponding to this identifier will be returned. If no such key exists, then no value is returned. In order to use hash keys that are not valid Qore identifiers, please use the {} operator.  If the member is a private member and access is made outside the class, a run-time exception will be thrown.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>method_ídentifier</replaceable></para></entry>
	  <entry><para>The container expression must evaluate to an object, or a run-time exception is thrown.  If the method does not exist in the class a run-time exception is thrown.  Otherwise the method is called with any optional arguments given.</para></entry>
	</row>

      </tbody>
    </tgroup>
  </table>
  
  <table>
    <title>Exceptions Thrown by .</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para>PRIVATE-MEMBER</para></entry>
	  <entry><para>Attempt to access a private member outside the class.</para></entry>
	</row>
	<row>
	  <entry><para>METHOD-DOES-NOT-EXIST</para></entry>
	  <entry><para>Attempt to access a method not defined for this class.</para></entry>
	</row>
	<row>
	  <entry><para>METHOD-IS-PRIVATE</para></entry>
	  <entry><para>Attempt to access a private method from outside the class.</para></entry>
	</row>
	<row>
	  <entry><para>BASE-CLASS-IS-PRIVATE</para></entry>
	  <entry><para>Attempt to access a method of a privately-inherited base class from outside the class.</para></entry>
	</row>
	<row>
	  <entry><para>OBJECT-METHOD-EVAL-ON-NON-OBJECT</para></entry>
	  <entry><para>Attempt to execute a method on a non-object.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

</sect2>
<sect2 id="List_Dereference_Operator">
  <title>List Dereference Operator ([])</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Retrieves the value of a list element.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>list_expression[expression]</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>printf("%s\n", $list[2]);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  
  <table>
    <title>Arguments Processed By []</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>list_expression</replaceable></para></entry>
	  <entry><para>This expression must evaluate to a list. If not, then the operator returns no value.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>expression</replaceable></para></entry>
	  <entry><para>The expression is evaluated and converted to an integer if necessary. Then the value of the list element given is returned (elements start at position 0).</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>
</sect2>

<sect2 id="Pre_Increment_Operator">
  <title>Integer Pre-Increment Operator (++)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>increments an lvalue and returns the incremented value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>++lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>++$i;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Pre-Increment ++</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then increments the value and returns the result.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Post_Increment_Operator">
  <title>Integer Post-Increment Operator (++)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>increments an lvalue and returns the value before the increment.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue++</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$i++;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Post-Increment ++</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then saves this value as the result, then increments the lvalue, then returns the saved original value of <replaceable>lvalue</replaceable> (after conversion to an integer if necessary)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  
  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Pre_Decrement_Operator">
  <title>Integer Pre-Decrement Operator (--)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>decrements an lvalue and returns the decremented value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>--lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>--$i;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Pre-Decrement --</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then decrements it and returns the result.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Post_Decrement_Operator">
  <title>Integer Post-Decrement Operator (--)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>increments an lvalue and returns the value before the increment.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue++</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$i++;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Post-Increment ++</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then saves this value as the result, then increments the lvalue, then returns the saved original value of <replaceable>lvalue</replaceable> (after conversion to an integer if necessary)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  
  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Pre_Decrement_Operator">
  <title>Integer Pre-Decrement Operator (--)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>decrements an lvalue and returns the decremented value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>--lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>--$i;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Pre-Decrement --</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then decrements it and returns the result.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Post_Decrement_Operator">
  <title>Integer Post-Decrement Operator (--)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>decrements an lvalue and returns the value before the decrement.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue--</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$i--;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Post-Decrement --</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts <replaceable>lvalue</replaceable> to an integer if necessary, then saves this value as the result, then decrements the value, then returns the saved original value of <replaceable>lvalue</replaceable> (after conversion to an integer if necessary)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="New_Object_Operator">
  <title>New Object Operator (new)</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Creates an instance of a class and runs the class' constructor on the new class (if any exists).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>new</command> <replaceable>class_identifier(constructor_arguments ...)</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting></programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table>
    <title>Arguments Processed By new</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>class_identifier</replaceable></para></entry>
	  <entry><para>The class_identifier must be an existing class name; if so, the operator instantiates an object of this class, executes the constructor for the class (if any exists, along with any base class constructors, if applicable) on the new object, and returns the object (for constructor execution order in an inherited class, see <link linkend='Class_Inheritance'>Class Inheritance</link>).  If an exception is thrown in the constructor, the object is deleted and NOTHING is returned.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  <table>
    <title>Exceptions Thrown by new</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>depends on class/constructor</para></entry>
	  <entry><para>See class documentation for possible exceptions.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
</sect2>

<sect2 id="Background_Operator">
  <title>Background Operator (background)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Start a background thread and return the TID (thread ID).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>background</command> <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>background</command> startThread();</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By background</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable></para></entry>
	  <entry>
	    <para>The expression given as an argument will be executed in a new thread. The TID of the new thread will be returned as the return value of the operator. </para>      
	  </entry>
	</row>
      </tbody>
    </tgroup>
  </table>

<note>
  <para>Please note the following when using the background operator:</para>
  <itemizedlist mark='bullet'>
    <listitem>
      <para>expressions that have no effect cannot be used with the background operator (a parse exception will be thrown)</para>
    </listitem>
    <listitem>
      <para>it is illegal to make changes to a local variable anywhere in a background expression (a parse exception will be thrown)</para>
    </listitem>
    <listitem>
      <para>local variables and <command>find</command> expressions are evaluated before the new thread is started and the result of the evaluation is used in the expression in the new thread.</para>
    </listitem>
    <listitem>
      <para>it is not possible to pass local variables by reference anywhere in a background expression (a parse exception will be thrown)</para>
    </listitem>
  </itemizedlist>
</note>

  <table>
    <title>Exceptions Thrown by background</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>THREAD-CREATION-FAILURE</para></entry>
	  <entry><para>If the thread table is full or if the operating system returns an error while starting the thread, this exception is thrown.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

</sect2>
<sect2 id="Logical_Not_Operator">
  <title>Logical Not Operator (!)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Reverses the logical sense of an expression (True becomes False and False becomes True).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting>!<replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> (!<command>exists</command> $error_code)
    do_something();</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By !</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable></para></entry>
	  <entry><para>The expression is evaluated and converted to Boolean, if necessary. Then the value is logically reversed (True becomes False, False becomes True)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Binary_Not_Operator">
  <title>Binary Not Operator (~)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The value of each bit in an integer is reversed (0 becomes 1, 1 becomes 0).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting>~<replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = ~$b;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By ~</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable>: Integer</para></entry>
	  <entry><para>Performs bitwise negation on its argument (ex: 666 &amp; ~27 = 640)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Unary_Minus_Operator">
  <title>Unary Minus Operator (-)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Changes the sign of numeric values.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting>-<replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = -$b;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Unary Minus -</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable>: Float</para></entry>
	  <entry><para>Gives the negative of its argument (ex: -(-1.1) = 1.1, -(1.1) = -1.1 </para></entry>
	</row>
	<row>
	  <entry><para><replaceable>expression</replaceable>: Integer</para></entry>
	  <entry><para>Gives the negative of its argument (ex: -(-1) = 1, -(1) = -1</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Shift_Operator">
  <title>Shift Operator (shift)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Removes the first element from a list and returns that element.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>shift</command> <replaceable>lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = <command>shift</command> $ARGV;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By shift</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>lvalue</replaceable>: List</para></entry>
	  <entry><para>Returns the first element of the list, and the list is modified by having the first element removed from the list.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Pop_Operator">
  <title>Pop Operator (pop)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Removes the last element from a list and returns that element.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>pop</command> <replaceable>lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = <command>pop</command> $list;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By pop</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>lvalue</replaceable>: List</para></entry>
	  <entry><para>Returns the last element of the list, and the list is modified, having the last element removed from the list.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Elements_Operator">
  <title>Elements Operator (elements)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Returns the number of elements in a list or the number of keys in a hash.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>elements</command> <replaceable>container_expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$size = <command>elements</command> $list;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By keys</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>List</para></entry>
	  <entry><para>Returns the number of elements in the list.</para></entry>
	</row>
	<row>
	  <entry><para>Hash</para></entry>
	  <entry><para>Returns the number of keys in the hash.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  <para>This operator does not throw any exceptions.</para>
</sect2>

<sect2 id="Keys_Operator">
  <title>Keys Operator (keys)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Returns a list representing the keys in a hash.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>keys</command> <replaceable>hash_expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>foreach</command> <command>my</command> $key in (<command>keys</command> $hash)
    printf("%s = %s\n", $key, $hash.$key);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By keys</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>hash_expression</replaceable></para></entry>
	  <entry><para>Returns a list of strings giving the keys in <replaceable>hash_expression</replaceable>, which must evaluate to a hash.  If not, then no value is returned.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  <para>This operator does not throw any exceptions.</para>
</sect2>

<sect2 id="Multiply_Operator">
  <title>Multiply Operator (*)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Multiplies two arguments.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> * <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$value = $x * $y</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Argument Processing and Conversion Priorities for *</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>Gives the result of multiplying its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of multiplying its arguments.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Divide_Operator">
  <title>Divide Operator (/)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Divides a number by another.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> / <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$value = $x / $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  
  <table>
    <title>Argument Processing and Conversion Priorities for /</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>Gives the result of dividing its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of dividing its arguments.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Modula_Operator">
  <title>Modula Operator (%)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Gives the integer remainder after division of one number by another.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> % <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$mod = $x % $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By %</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives <replaceable>expression1</replaceable> modula <replaceable>expression2</replaceable> (ex: 12 % 10 = 2).  Arguments are converted to integers if necessary.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Plus_Operator">
  <title>Plus (Addition and Concatentation) Operator (+)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	Numeric addition, list, string, and hash concatenation operator.
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> + <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1 + 2;</programlisting>
	<programlisting>$string = "hello" + "-there";</programlisting>	
	<programlisting>$list = (1, 2) + ("three", "four", "five");</programlisting>
	<programlisting>$hash = ( "key1" : 1, "key2" : 2) + ( "key3" : "three", "key4": "four");</programlisting>	
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Argument Processing and Conversion Priorities for +</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>List</para></entry>
	  <entry><para>Gives the result of concatenating its arguments, i.e. (1, 2) + (3, 4) = (1, 2, 3, 4)</para></entry>
	</row>
	<row>
	  <entry><para>String</para></entry>
	  <entry><para>Gives the result of concatenating its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Date</para></entry>
	  <entry><para>Gives the result of adding dates (see section <link linkend='Date_Arithmetic'>Date Arithmetic</link>)</para></entry>
	</row>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>Gives the result of adding its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of adding its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Hash</para></entry>
	  <entry><para>Gives the result of concatenating/merging its arguments. Any common keys will be overwritten by the values in the second hash (<replaceable>expression2</replaceable>)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Minus_Operator">
  <title>Minus Operator (-)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Subtracts one number from another.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> - <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$num = $x - $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Argument Processing and Conversion Priorities for -</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>arithmetic subtraction: <replaceable>expression1</replaceable> - <replaceable>expression2</replaceable></para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>arithmetic subtraction: <replaceable>expression1</replaceable> - <replaceable>expression2</replaceable></para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Shift_Right_Operator">
  <title>Shift Right Operator (&gt;&gt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Shifts bits in an integer towards zero (divides an integer by a power of 2)</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &gt;&gt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x &gt;&gt; $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By &gt;&gt;</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>Integer</para></entry>
	<entry><para>Gives the result of shifting <replaceable>expression1</replaceable> right by <replaceable>expression2</replaceable> bits.  Arguments are converted to integers if necesssary.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Shift_Left_Operator">
  <title>Shift Left Operator (&lt;&lt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Shifts bits in an integer towards infinity (multiplies an integer by a power of 2)</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt;&lt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x &lt;&lt; $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By &lt;&lt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Gives the result of shifting <replaceable>expression1</replaceable> left by <replaceable>expression2</replaceable> bits.  Arguments are converted to integers if necessary.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Exists_Operator">
  <title>Exists Operator (exists)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if an expression represents a value or not.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>exists</command> <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> (<command>exists</command> $a)
    printf("a = $n\n", $a);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>



<table><title>Arguments Processed By exists</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para><replaceable>expression</replaceable></para></entry>
    <entry><para>If <replaceable>expression</replaceable> evaluates to a value, then the operator returns True, otherwise returns False.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Less_Than_Operator">
  <title>Less Than Operator (&lt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is less than another.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &lt; $y)
    printf("%n is less than %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for &lt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically less than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically less than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes before <replaceable>expression2</replaceable> in string sort order, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is before <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Greater_Than_Operator">
  <title>Greater Than Operator (&gt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is greater than another.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>

      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &gt; $y)
    printf("%n is less than %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<programlisting><replaceable>expression1</replaceable> &gt; <replaceable>expression2</replaceable></programlisting>

<table><title>Argument Processing and Conversion Priorities for &gt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes after <replaceable>expression2</replaceable> in string sort order, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is after <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Equals_Operator">
  <title>Equals Operator (==)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is equal to another.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> == <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x == $y)
    printf("%n is equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for ==</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>List</para></entry>
    <entry><para>If each element in the each list where order is relevant satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Hash</para></entry>
    <entry><para>If each hash has the same keys and the value of each equal key in each hash satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Binary</para></entry>
    <entry><para>If <replaceable>expression1</replaceable>'s memory contents and size are equal to <replaceable>expression2</replaceable>'s, then returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Object</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is a reference to the same object as <replaceable>expression2</replaceable>, then returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para><command>NULL</command></para></entry>
    <entry><para>If both expressions are <command>NULL</command>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para><command>NOTHING</command></para></entry>
    <entry><para>If neither expression has a value, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Not_Equals_Operator">
  <title>Not Equals Operator (!=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is not equal to another.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> != <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x != $y)
    printf("%n is not equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for !=</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>List</para></entry>
    <entry><para>If any element in the each list compared where order is relevant satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Hash</para></entry>
    <entry><para>If the hashes have different key sets, or the values of any equal key in each hash satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Binary</para></entry>
    <entry><para>If either <replaceable>expression1</replaceable>'s memory contents and size are not equal to <replaceable>expression2</replaceable>'s, returns True, otherwise False.</para></entry>
  </row>
  <row>
    <entry><para>Object</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not a reference to the same object as <replaceable>expression2</replaceable>, then returns True, otherwise False.</para></entry>
  </row>
  <row>
    <entry><para><command>NULL</command></para></entry>
    <entry><para>If one expression is <command>NULL</command> and the other not, returns True, otherwise False.</para></entry>
  </row>
  <row>
    <entry><para><command>NOTHING</command></para></entry>
    <entry><para>If one of the expressions has a value, returns True, otherwise False.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Less_Than_Or_Equals_Operator">
  <title>Less Than Or Equals Operator (&lt;=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is less than or equals to another value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt;= <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &lt;= $y)
    printf("%n is less than or equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Argument Processing and Conversion Priorities for &lt;=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>Float</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> is numerically less than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
      <row>
	<entry><para>Integer</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> is numerically less than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
      <row>
	<entry><para>String</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> comes before in string sort order or is the same as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
      <row>
	<entry><para>Date</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> is before or is the same exact date and time as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Greater_Than_Or_Equals_Operator">
  <title>Greater Than Or Equals Operator (>=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is greater than or equals to another value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &gt;= <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &gt;= $y)
    printf("%n is greater than or equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for &gt;=</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes after in string sort order or is the same as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is after or is the same exact date and time as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Comparison_Operator">
  <title>Comparison (&lt;=&gt;) Operator</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is less than, equal, or greater than another value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt;=&gt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>switch</command> ($x &lt;=&gt; $y)
{
    <command>case</command> -1: 
        print("x is less than $y\n");
        <command>break</command>;

    <command>case</command> 0: 
        print("x is equal to $y\n");
        <command>break</command>;

    <command>case</command> 1: 
        print("x is greater than $y\n");
        <command>break</command>;
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>



<table><title>Argument Processing and Conversion Priorities for &lt;=&gt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes after in string sort order as <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal, returns 0, otherwise if <replaceable>expression1</replaceable> comes before <replaceable>expression2</replaceable>, returns -1</para></entry>
  </row>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal returns 0, otherwise returns -1</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal returns 0, otherwise returns -1</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is after <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal returns 0, otherwise returns -1</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Absolute_Equals_Operator">
  <title>Absolute Equals Operator (===)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks two values for equality without doing any data type conversions; if the types do not match, then the result is False.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> === <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x === $y)
    printf("%n is equal to %n and has the same data type as well\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ===</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>This operator returns True only if the types and values of both sides of the operator are exactly equal, otherwise returns False. No type conversions are done.</para></entry>
  </row>
</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Absolute_Not_Equals_Operator">
  <title>Absolute Not Equals Operator (!==)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks two values for inequality without doing any data type conversions.  If the data types do not match, then returns True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<para><replaceable>expression1</replaceable> !== <replaceable>expression2</replaceable></para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x !== $y)
    printf("%n is not equal to %n and may not have the data type as well\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By !==</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>This operator returns True if either the types or the values of the arguments are different, otherwise it retuns False. No type conversions are done.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Regular_Expression_Match_Operator">
  <title>Regular Expression Match Operator (=~)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks for a regular expression match.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression</replaceable> =~ <replaceable>regex</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($str =~ /hello/)
    printf("%s contains 'hello'\n", $str);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By =~</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>This operator returns True if the regular expression in <replaceable>regex</replaceable> matches the string in <replaceable>expression</replaceable>.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Regular_Expression_No_Match_Operator">
  <title>Regular Expression No Match Operator (!~)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks for a regular expression non match.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression</replaceable> !~ /<replaceable>regex</replaceable>/</programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($str !~ /hello/)
    printf("%s does not contain 'hello'\n", $str);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By !~</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>String</para></entry>
	  <entry><para>This operator returns True if the regular expression in <replaceable>regex</replaceable> does not match the string in <replaceable>expression</replaceable>.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Regular_Expression_Substitution_Operator">
  <title>Regular Expression Substitution Operator</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Looks for a regular expression match in a string, and, if found, substitutes the matched string with a new string.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> =~ s/<replaceable>regex</replaceable>/<replaceable>text</replaceable>/[g]</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$str =~ s/hello/goodbye/;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By =~ s//</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>This operator substitutes text in the <replaceable>lvalue</replaceable> string if the regular expression matches.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Binary_And_Operator">
  <title>Binary And Operator (&amp;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) AND operation on two integers.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &amp; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x &amp; $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By &amp;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Gives the result of the binary (bitwise) AND operation between <replaceable>expression1</replaceable> and <replaceable>expression2</replaceable> (ex: 0xffb2 &amp; 0xa1 = 0xa1)</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Binary_Or_Operator">
  <title>Binary Or Operator (|)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) OR operation on two integers.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> | <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x | $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By |</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of the binary (bitwise) OR operation between <replaceable>expression1</replaceable> and <replaceable>expression2</replaceable> (ex: 0xb001 | 0xfea = 0xbfeb)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Binary_Xor_Operator">
  <title>Binary Xor Operator (^)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) XOR operation on two integers.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> ^ <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x ^ $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ^</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Gives the result of the binary (bitwise) EXCLUSIVE OR operation between <replaceable>expression1</replaceable> and <replaceable>expression2</replaceable> (ex: 0xaef1 &amp; 0xfb32 = 
      0x55c3)</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Logical_And_Operator">
  <title>Logical And Operator (&amp;&amp;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks to see if two expressions are True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &amp;&amp; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &amp;&amp; $y)
    printf("%n and %n are both True\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By &amp;&amp;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Returns True if both expressions are True, False if otherwise.  Logical short-circuiting is implemented; if <replaceable>expression1</replaceable> is False, then <replaceable>expression2</replaceable> is not evaluated, and the operator returns False.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Logical_Or_Operator">
  <title>Logical Or Operator (||)</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Returns True if either of the arguments are True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> || <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x || $y)
    printf("either %n or %n or both are True\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ||</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Returns True if either or both expressions evaluate to True, False if otherwise.  Logical short-circuiting is implemented; if <replaceable>expression1</replaceable> is True, then <replaceable>expression2</replaceable> is not evaluated, and the operator returns True.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Conditional_Operator">
  <title>Conditional Operator (? :)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Evaluates and returns the value of one of two expressions depending on the value of a conditional expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression ? if_true_expression : if_false_expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = ($z > 100 ? "Big" : "Small");</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By ? :</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>If <replaceable>expression</replaceable> is evaluated to be True, then the <replaceable>if_true_expression</replaceable> is evaluated and returned. Otherwise the <replaceable>if_false_expression</replaceable> is evaluated and returned.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Comma_Operator">
  <title>Comma Operator (,)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Makes a list from more than one element.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1, expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1, 2, "three";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ,</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>The comma operator builds lists of arguments.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Unshift_Operator">
  <title>Unshift Operator (unshift)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Inserts an element into the first position of a list and moves all other elements up one position.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>unshift</command> <replaceable>lvalue, expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>unshift</command> $list, "one";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By unshift</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>Inserts the value of <replaceable>expression</replaceable> as the first element in the list given by <replaceable>lvalue</replaceable>.  All other elements in the list are moved forward.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2 id="Push_Operator">
  <title>Push Operator (push)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Adds one element to the end of a list.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>push</command> <replaceable>lvalue, expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>push</command> $list, "last";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By push</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>Appends the value of the expression as the last element in the list given by <replaceable>lvalue</replaceable>.  If <replaceable>expression</replaceable> evaluates to a list, this list will be appended as the last element of <replaceable>lvalue</replaceable>.  To concatenate lists, use the <link linkend='Plus_Operator'>Plus Operator</link>.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2 id="Splice_Operator">
  <title>Splice Operator (splice)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Removes and optionally inserts elements in lists and strings.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>splice</command> <replaceable>lvalue, offset_expression, [length_expression, [substitution_expression]]</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>splice</command> $list, 2, 2;</programlisting>
	<programlisting><command>splice</command> $string, 2, 2, "-text-";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>


  <para>Works on either strings or lists in a similar way; removes elements from a list or characters from a string and optionally inserts new ones.  If no <replaceable>length_expression</replaceable> is given, <command>splice</command> removes all elements/characters from the list or string starting at <replaceable>offset_expression</replaceable>) (list and string offsets begin at 0).  Otherwise, a number of elements/characters equal to <replaceable>length_expression</replaceable> is removed (or up to the end of the list/string if applicable).  If <replaceable>substitution_expression</replaceable> is present, then the removed elements/characters are substituted with the elements/string given by this expression.</para>

  <table>
    <title>Arguments Processed By splice</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>lvalue</replaceable></para></entry>
	  <entry><para>If the lvalue is a list, list elements are processed, otherwise, if it is a string, characters in the string are processed.  For any other data type, no action is taken.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>offset_expression</replaceable></para></entry>
	  <entry><para>The start element/character position for removing elements/characters from the list or string.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>length_expression</replaceable></para></entry>
	  <entry><para>The number of elements/characters to remove.  If this expression is not present, then all elements/characters from the offset to the end of the list/string are removed.  If this expression is present and evaluates to 0, no characters are removed.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>substitution_expression</replaceable></para></entry>
	  <entry><para>For list splice, an optional element or list to substitute for the removed elements.  For string splice, an optional string to substitute for the removed characters.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
</sect2>

<sect2 id="Assignment_Operator">
  <title>Assignment Operator (=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Assigns a value to an lvalue.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> = <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Types Processed =</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>    
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>Assigns the value of <replaceable>expression</replaceable> to <replaceable>lvalue</replaceable>.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>  
</sect2>

<sect2 id="Plus_Equals_Operator">
  <title>Plus Equals Operator (+=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Increments and concatentates an lvalue with the value of an expression depending on the data type of the lvalue.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> += <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a += 10;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By +=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: List</para></entry>
	<entry><para>the expression will be evaluated and concatenated to the lvalue.  If expression is a list, the lists will be concatenated, to ensure adding a single element to a list, use the push operator (see <link linkend='Push_Operator'>Push Operator</link>).</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: Hash</para></entry>
	<entry><para>the expression will be evaluated, and, if it is a hash or object, then it's members will be added to the lvalue, any duplicate elements in the lvalue will be overridden by elements in the expression.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: String</para></entry>
	<entry><para>the expression will be evaluated and converted to a string if necessary and concatenated to the lvalue.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: Float</para></entry>
	<entry><para>the expression will be evaluated and converted to a float if necessary and added to the lvalue.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: all others</para></entry>
	<entry><para>the lvalue's type will be converted to an integer, and the expression will be evaluated and converted to an integer if necessary, and then the result will be added to the lvalue.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Minus_Equals_Operator">
  <title>Minus Equals Operator (-=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Decrements the value of an lvalue by the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> -= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a -= 10;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By -=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: Float</para></entry>
	<entry><para>the expression will be evaluated and converted to a float if necessary and subtracted from the lvalue</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: all others</para></entry>
	<entry><para>the lvalue's type will be converted to an integer, and the expression will be evaluated and converted to an integer if necessary, and then the result will be subtracted from the lvalue</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="And_Equals_Operator">
  <title>And Equals Operator (&amp;=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) AND operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> &amp;= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a &amp;= 0xfe;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By &amp;=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>the lvalue's type will be converted to an integer if necessary, and the expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary and'ed to the lvalue</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Or_Equals_Operator">
  <title>Or Equals Operator (|=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) OR operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> |= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a |= 0xba;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By |=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>the lvalue's type will be converted to an integer if necessary, and the expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary or'ed to the lvalue</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>
</sect1>

<sect1 id="Date_Arithmetic">
  <title>Date Arithmetic</title>

  <para>Date arithmetic is relatively straightforward and should normally produce the expected results.  However with leap years and months with different lengths, the situation can be confusing; this section will clarify how Qore does date arithmetic considering these special cases.</para>

  <sect2 id="Addding_And_Subtracting_Years_And_Monts">
    <title>Adding and Subtracting Years and Months</title>

    <para>Adding or subtracting years and months (ex: $date += 2Y + 3M) will give you the same day on the desired month in the desired year. If the target month has fewer days than the source month, then you will get the last day of the month in that year. For example:</para>

    <programlisting>2004-02-29 - 1Y = 2003-02-28</programlisting>
  </sect2>

  <sect2 id="Addding_And_Subtracting_Days">
    <title>Adding and Subtracting Days</title>
    <para>Adding or subtracting days does not mean adding or subtracting 24h periods.  In most cases, one day represents 24 hours, but in the case of daylight savings time changes, a day can be 23 or 25 hours.</para>
  </sect2>

  <sect2 id="Timezones_And_Daylight_Savings_Time">
    <title>Timezones and Daylight Savings Time </title>
    <para>Unless otherwise documented, all times are assumed to be in the timezone set for the system.  Daylight Savings Time is taken into effect for date addition and subtraction.</para>
  </sect2>

</sect1>

<sect1 id="Statements">
  <title>Statements</title>

  <para>Non-block statements in Qore are always terminated by a semi-colon ";" as in Perl, C, or Java. Statements can be grouped into blocks, which are delimited by curly brackets "{" and "}" containing zero or more semi-colon delimited statements, as in C or Java. Like C, C++, and Java, but unlike perl, any Qore statement taking a statement modifier will accept a single statement or a statement block.</para>

<para>A statement can be any of the following (note that statements are also recursively defined):</para>

<table><title>Qore Statements</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>

  <thead>
  <row>
    <entry><para>Type</para></entry>
    <entry><para>Examples</para></entry>
    <entry><para>Reference</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>An expression that changes an lvalue</para></entry>
    <entry><programlisting>$var = 1;
$var += 5;
$var[1].count++;
<command>shift</command> $var.key[$i];</programlisting></entry>
    <entry><link linkend="Expressions">Expressions</link></entry>
  </row>
  <row>
    <entry><para>An expression with the <command>new</command> operator</para></entry>
    <entry><programlisting><command>new</command> ObjectClass(1, 2, 3);</programlisting></entry>
    <entry><link linkend='New_Object_Operator'>class instantiation/new object operator</link></entry>
  </row>
  <row>
    <entry><para>An expression with the <command>background</command> operator</para></entry>
    <entry><programlisting><command>background</command> function();</programlisting></entry>
    <entry><link linkend='Background_Operator'>background/thread creation operator</link></entry>
  </row>
  <row>
    <entry><para>A method call</para></entry>
    <entry><programlisting>$object.method(1, 2, 3);</programlisting></entry>
    <entry><link linkend="Classes">Classes</link> </entry>
  </row>
  <row>
    <entry><para>An "if" statement </para></entry>
    <entry><programlisting><command>if</command> ($var == 3) <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='if_and_else_Statements'>if and else Statements</link></para></entry>
  </row>
  <row>
    <entry><para>An "if ... else" statement</para></entry>
    <entry><programlisting><command>if</command> ($var == 3) <replaceable>statement </replaceable><command>else</command> <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='if_and_else_Statements'>if and else Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A while statement</para></entry>
    <entry><programlisting><command>while</command> ($var &lt; 10) 
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='while_Statements'>while Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A do while statement</para></entry>
    <entry><programlisting><command>do</command> <replaceable>statement</replaceable> <command>while</command> 
    (<replaceable>expression</replaceable>);</programlisting></entry>
    <entry><para><link linkend='do_while_Statements'>do while Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A for statement</para></entry>
    <entry><programlisting><command>for</command> (<replaceable>expression1</replaceable>; <replaceable>expression2</replaceable>; 
    <replaceable>expression3</replaceable>) <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='for_Statements'>for Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A foreach statement</para></entry>
    <entry><programlisting><command>foreach</command> <replaceable>$variable</replaceable> <command>in</command> 
    (<replaceable>expression</replaceable>) <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='foreach_Statements'>Foreach Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A switch statement</para></entry>
    <entry><programlisting><command>switch</command> (<replaceable>expression</replaceable>) 
{
    <command>case</command> <replaceable>constant_expression</replaceable>: 
        <replaceable>statement(s)</replaceable> 
    [ <command>default</command> : 
        <replaceable>statement(s)</replaceable> ]
}</programlisting>
    </entry>
    <entry><para><link linkend='switch_Statements'>switch Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A return statement</para></entry>
    <entry><programlisting><command>return</command> <replaceable>expression</replaceable>;</programlisting></entry>
    <entry><para><link linkend='Subroutines'>Subroutines</link></para></entry>
  </row>
  <row>
    <entry><para>A local variable declaration</para></entry>
    <entry>
	<programlisting><command>my</command> $var;
<command>my</command> ($a, $b, $c);</programlisting>
    </entry>
    <entry><para><link linkend='Variables'>Variables</link></para></entry>
  </row>
  <row>
    <entry><para>A global variable declaration</para></entry>
    <entry>
      <programlisting><command>our</command> $var;
<command>our</command> ($a, $b, $c);</programlisting>
    </entry>
    <entry><para><link linkend='Variables'>Variables</link></para></entry>
  </row>
  <row>
    <entry><para>A function call</para></entry>
    <entry><programlisting>calculate($this, $that, $the_other);</programlisting></entry>
    <entry><para><link linkend="Function_Library">Function Library</link></para></entry>
  </row>
  <row>
    <entry><para>A continue statement</para></entry>
    <entry><programlisting><command>continue</command>;</programlisting></entry>
    <entry><para><link linkend='continue_Statements'>continue Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A break statement</para></entry>
    <entry><programlisting><command>break</command>;</programlisting></entry>
    <entry><para><link linkend='break_Statements'>break Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A statement block</para></entry>
    <entry><programlisting>{ <replaceable>statement</replaceable> }</programlisting></entry>
    <entry><para>one or more statements enclosed in curly brackets.</para></entry>
  </row>
  <row>
    <entry><para>A delete statement</para></entry>
    <entry><programlisting><command>delete</command> <replaceable>$lvalue</replaceable>;</programlisting></entry>
    <entry><para><link linkend='delete_Statements'>delete Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A throw statement</para></entry>
    <entry><programlisting><command>throw</command> <replaceable>expression</replaceable>;</programlisting></entry>
    <entry><para><link linkend='throw_Statements'>throw Statements</link></para></entry>
  </row>
  <row>
    <entry><para>Try and catch statements</para></entry>
    <entry><programlisting><command>try</command>
    <replaceable>statement</replaceable>
<command>catch</command> (<replaceable>$vars ...</replaceable>)
    <replaceable>statement</replaceable></programlisting>
      </entry>
    <entry><para><link linkend='try_and_catch_Statements'>try and catch Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A rethrow statement</para></entry>
    <entry><programlisting><command>rethrow</command>;</programlisting></entry>
    <entry><para><link linkend='rethrow_Statements'>rethrow Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A thread_exit statement</para></entry>
    <entry><programlisting><command>thread_exit</command>;</programlisting></entry>
    <entry><para><link linkend='thread_exit_Statements'>thread_exit Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A context statement</para></entry>
    <entry>
      <programlisting><command>context</command> <replaceable>[name] (expression)</replaceable> 
    <replaceable>statement</replaceable></programlisting>
    </entry>
    <entry><para><link linkend='context_Statements'>context Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A summarize statement</para></entry>
    <entry>
      <programlisting><command>summarize</command> <replaceable>expression</replaceable> by ( <replaceable>expression</replaceable> )
    <replaceable>statement</replaceable></programlisting>
    </entry>
    <entry><para><link linkend='summarize_Statements'>summarize Statements</link></para></entry>
  </row>
  <row>
    <entry><para>A subcontext statement</para></entry>
    <entry><programlisting><command>subcontext</command>
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='subcontext_Statements'>subcontext Statements</link></para></entry>
  </row>

</tbody>
</tgroup>
</table>

<sect2 id="if_and_else_Statements">
  <title>if and else Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The <command>if</command> statement allows for conditional logic in a Qore program's flow; the syntax is similar to that of C, C++, or Java.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>if</command> ( <replaceable>expression</replaceable> ) 
    <replaceable>statement</replaceable>
[<command>else</command>
    <replaceable>statement</replaceable>]</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>Qore if statements work like if statements in C or Java.  If the result of evaluating the expression converted to a Boolean value is True, then the first statement (which can also be a block) is executed.  If the result is False, and there is an else keyword after the first statement, the following statement is executed.</para>
     </listitem>
    </varlistentry>
  </variablelist>
  <note>
    <para>Any expression that evaluates to a non-zero integer value will be converted to a Boolean True.  Any expression that evaluates to zero value is interpreted as False.  This is more like C and Java's behavior and not like Perl's (where any non-null string except "0" is True).</para>
  </note>

</sect2>
<sect2 id="for_Statements">
  <title>for Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The Qore <command>for</command> statement is most similar to the <command>for</command> statement in C and Java, or the non array iterator <command>for</command> statement in Perl.  This statement is ideal for loops that should execute a given number of times, then complete.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>for</command> ( <replaceable>initial_expression</replaceable> ; <replaceable>test_expression</replaceable> ; <replaceable>iterator_expression</replaceable> )
      <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para><replaceable>initial_expression</replaceable></para>
	<para>The <replaceable>initial_expression</replaceable> is executed only once at the start of each <command>for</command> loop. It is typically used to initialize a loop variable.</para>
	<para><replaceable>test_expression</replaceable></para>
	<para>The <replaceable>test_expression</replaceable> is executed at the start of each <command>for</command> loop iteration. If this expression evaluates to Boolean False, the loop will terminate.</para>
	<para><replaceable>iterator_expression</replaceable></para>
	<para>The <replaceable>iterator_expression</replaceable> is executed at the end of each <command>for</command> loop iteration. It is typically used to increment or decrement a loop variable that will be used in the <replaceable>test_expression</replaceable>.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<para>Here is an example of a <command>for</command> loop using a local variable:</para>
	<programlisting><command>for</command> (<command>my</command> $i = 0; $i &lt; 10; $i++)
    print("%d\n", $i);</programlisting>
     </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="foreach_Statements">
  <title>foreach Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The Qore <command>foreach</command> statement is most similar to the <command>for</command> or <command>foreach</command> array iterator statement in Perl.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>foreach</command> [<command>my</command>] <replaceable>$variable</replaceable> <command>in</command> (<replaceable>expression</replaceable>)
    <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>If the <replaceable>expression</replaceable> does not evaluate to a list, then the variable will be assigned the value of the expression evaluation and the statement will only execute one time.  Otherwise the variable will be assigned to each value of the list and the statement will be called once for each value.</para>
     </listitem>
    </varlistentry>
  </variablelist>

  <note><para>Note that if a reference (<replaceable>\$lvalue_expression</replaceable>) is used as the list expression, any changes made to the <command>foreach</command> iterator variable will be written back to the list.</para></note>

</sect2>
<sect2 id="switch_Statements">
  <title>switch Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The Qore <command>switch</command> statement is similar to the <command>switch</command> statement in C and C++, except that the <command>case</command> values can be any expression that does not need run-time evaluation.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>switch</command> (<replaceable>expression</replaceable>) 
{ 
    <command>case</command> <replaceable>constant_expression</replaceable>: 
        <replaceable>statement(s)</replaceable> 
    ...
    [ <command>default</command> : 
        <replaceable>statement(s)</replaceable> ]
}</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The first expression is evaluated and then compared to the value of each <command>case</command> expression in declaration order.  The comparisons are "hard" comparisons; no type conversions are done, so in order for a match to be made, both the value and types of the expressions must match exactly.</para>
	<para>If no match is found and a <command>default</command> label has been given, then any statements after the <command>default</command> label will be executed.  If a match is made, then the statements following that <command>case</command> label are executed.</para>
	<para>To break out of the switch statement, use the <command>break</command> statement.</para>
     </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="while_Statements">
  <title>while Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para><command>while</command> statements in Qore are similar to <command>while</command> statements in Perl, C and Java. They are used to loop while a given condition is True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>while</command> ( <replaceable>expression</replaceable> )
    <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>First the <replaceable>expression</replaceable> will be evaluated; if it evaluates to True, then <replaceable>statement</replaceable> will be executed. If it evaluates to False, the loop terminates.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1;
<command>while</command> ($a &lt; 10)
    $a++;</programlisting>
     </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="do_while_Statements">
  <title>do while Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para><command>do</command> <command>while</command> statements in Qore are similar to <command>do</command> <command>while</command> statements in C.  They are used to guarantee at least one iteration and loop until a given expression evaluates to False.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>do</command>
    <replaceable>statement</replaceable>
<command>while</command> ( <replaceable>expression</replaceable> );</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>First, <replaceable>statement</replaceable> will be executed, then <replaceable>expression</replaceable> will be evaluated; if it evaluates to True, then the loop iterates again. If it evaluates to False, the loop terminates. The difference between <command>do</command> <command>while</command> statements and <command>while</command> statements is that the <command>do</command> <command>while</command> statement evaluates its loop expression at the end of the loop, and therefore guarantees at least one iteration of the loop.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
<programlisting>$a = 1;
<command>do</command> 
    $a++;
<command>while</command> ($a &lt; 10);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="continue_Statements">
<title>continue Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Skips the rest of a loop and jumps right to the evaluation of the iteration expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>continue</command>;</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The <command>continue</command> statement affects loop processing; that is; it has an affect on <command>for</command>, <command>foreach</command>, <command>while</command>, <command>do</command> <command>while</command>, <command>context</command>, <command>summarize</command>, and <command>subcontext</command> loop processing.  When this statement is encountered while executing a loop, execution control jumps immediately to the evaluation of the iteration expression, skipping any other statements that might otherwise be executed.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="break_Statements">
  <title>break Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Exits immediately from a loop statement or <command>switch</command> block.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>break</command>;</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The <command>break</command> statement affects loop processing; that is; it has an affect on <command>for</command>, <command>while</command>, <command>do</command> <command>while</command>, <command>context</command>, <command>summarize</command>, and <command>subcontext</command> loop processing. When this statement is encountered while executing a loop, the loop is immediately exited, and execution control passes to the next statement outside the loop.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="delete_Statements">
  <title>delete Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>In order to delete the contents of an lvalue, the <command>delete</command> statement can be used.  For objects, this will also run the destructor method (if defined for the class).</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>delete</command> <replaceable>$lvalue;</replaceable></programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="throw_Statements">
  <title>throw Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>In order to throw an exception explicitly, the <command>throw</command> statement must be used.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>throw</command> <replaceable>expression;</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The expression will be passed to the <command>catch</command> block of a <command>try</command>/<command>catch</command> statement, if the <command>throw</command> is executed in a <command>try</command> block.  Otherwise the default system exception handler will be run and the currently running thread will terminate.</para>
	<para>Qore convention dictates that a direct list is thrown with at least two string elements, the error code and a description.  All system exceptions have this format.  See <link linkend="try_and_catch_Statements">try and catch Statements</link> for information on how to handle exceptions, and see <link linkend="Exception_Handling">Exception Handling</link> for information about how <command>throw</command> arguments are mapped to the exception hash.</para>
      </listitem>
    </varlistentry>
  </variablelist>

</sect2>
<sect2 id="try_and_catch_Statements">
  <title>try and catch Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Some error conditions can only be detected and handled using exception handlers. To catch exceptions, <command>try</command> and <command>catch</command> statements can to be used.  When an exception occurs while executing the <command>try</command> block, execution control will immediately be passed to the <command>catch</command> block, which can capture information about the exception.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<para>
	  <programlisting><command>try</command>
    <replaceable>statement</replaceable>
<command>catch</command> ([<replaceable>$exception_hash_variable</replaceable>])
    <replaceable>statement</replaceable></programlisting>
	</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>A single variable can be specified in the <command>catch</command> block to be instantiated with the exception hash, giving information about the exception that has occurred.  For detailed information about the exception hash, see <link linkend="Exception_Handling">Exception Handling</link>.</para>

      <para>If no variable is given in the <command>catch</command> declaration, it will not be possible to access any information about the exception in the <command>catch</command> block.  However, the <command>rethrow</command> statement (see <link linkend="rethrow_Statements">rethrow Statements</link>) can be used to rethrow exceptions at any time, but only in a catch block.</para>      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

    <sect2 id="rethrow_Statements">
      <title>rethrow Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>A <command>rethrow</command> statement can be used to rethrow an exception in a <command>catch</command> block.  In this case a entry tagged as a rethrow entry will be placed on the exception call stack.  This statement can be used to maintain coherent call stacks even when exceptions are handled by more than one catch block (for detailed information about the exception hash and the format of call stacks, see <link linkend="Exception_Handling">Exception Handling</link>).</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>rethrow</command>;</programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>The rethrown exception will be either passed to the next higher-level catch block, or to the system default exception handler, as with a <command>throw</command> statement.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="thread_exit_Statements">
      <title>thread_exit Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para><command>thread_exit</command> statements cause the current thread to exit immediately.  Use this statement instead of the <link linkend="exit">exit()</link> function when only the current thread should exit.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>thread_exit</command>;</programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>This statement will cause the current thread to stop executing immediately.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

<sect2 id="context_Statements">
  <title>context Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>To easily iterate through multiple rows in a hash of arrays (such as a query result set returned by the <link linkend="Qore::SQL::Datasource::select">Datasource::select()</link> method), the <command>context</command> statement can be used. Column names can be referred to directly in expressions in the scope of the <command>context</command> statement by preceding the name with a '%" character.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<para>
	  <programlisting><command>context</command> [name] ( <replaceable>data_expression )</replaceable> 
        [ <command>where</command> ( <replaceable>expression</replaceable> ) ] 
        [ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ] 
        [ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]
   <replaceable>statement</replaceable></programlisting>
	</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para><replaceable>data_expression</replaceable></para>
	<para>This must evaluate to a hash of arrays in order for the <command>context</command> statement to execute.</para>

	<programlisting>[ <command>where</command> ( <replaceable>expression</replaceable> ) ]</programlisting>
	<para>An optional <command>where</command> 
	expression may be given, in which case for each row in the hash, 
	the expression will be executed, and if the <command>where</command> expression evaluates to True, 
	the row will be iterated in the <command>context</command> loop. If this expression evaluates 
	to False, then the row will not be iterated. This option is given so the 
	programmer can create multiple views of a single data structure (such as a query 
	result set) in memory rather than build different data structures by 
	hand.</para>

	<programlisting>[ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ]</programlisting>
	<para>An optional <command>sort_by</command> expression may also be given. In this case, the expression will be evaluated for each row of the query given, and then the result set will be sorted in ascending order by the results of the expressions according to the resulting type of the evaluated expression (i.e. if the result of the evaluation of the expression gives a string, then string order is used to sort, if the result of the evaluation is an integer, then integer order is used, etc).</para>

	<programlisting>[ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]</programlisting>
	<para>Another optional modifier to the context statement that behaves the same as above except that the results are sorted in descending order.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting># note that "%service_type" and "%effective_start_date" represent values
# in the $service_history hash of arrays.

<command>context</command> ($service_history) <command>where</command> (%service_type == "voice")
<command>sortBy</command> (%effective_start_date)
{
   printf("%s: start date: %s\n", %msisdn, format_date(%effective_start_date, "YYYY-MM-DD HH:mm:SS"));
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

</sect2>
<sect2 id="summarize_Statements">
  <title>summarize Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>
	  <command>summarize</command> statements are like <command>context</command> statements with one important difference: results sets are grouped by a by expression, and the statement is executed only once per discrete <command>by</command> expression result. This statement is designed to be used with the <command>subcontext</command> statement.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>summarize</command> ( <replaceable>expression </replaceable>) <command>by</command> ( <replaceable>expression</replaceable> )
          [ <command>where</command> ( <replaceable>expression</replaceable> ) ] 
          [ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ] 
          [ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]
   <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para><command>summarize</command> statements modifiers have the same effect as those for the <command>context</command> statement, except for the following:</para>

	<programlisting><command>by</command> ( <replaceable>expression</replaceable> )</programlisting>
	<para>The <command>by</command> expression is executed for each row in the data structure indicated. 
	The set of unique results defines groups of result rows. For each group of 
	result rows, each row having an identical result of the evaluation of the 
	<command>by</command> expression, the statement is executed only once.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting># note that "%service_type" and "%effective_start_date" represent values 
# in the $services hash of arrays.

<command>summarize</command> ($services) 
    <command>by</command> (%effective_start_date) 
    <command>where</command> (%service_type == "voice") 
    <command>sortBy</command> (%effective_start_date)
{
    printf("account has %d service(s) starting on %s\n", 
           context_rows(),
           format_date(%effective_start_date, "YYYY-MM-DD HH:mm:SS"));
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="subcontext_Statements">
  <title>subcontext Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Statement used to loop through values within a summarize statement.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>subcontext</command> [ <command>where</command> ( <replaceable>expression</replaceable> ) ] 
           [ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ] 
           [ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]
    <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The <command>subcontext</command> statement is used in conjunction with <command>summarize</command> statements. When result rows of a query should be grouped, and then each row in the result set should be individually processed, the Qore programmer should first use a <command>summarize</command> statement, and then a <command>subcontext</command> statement. The <command>summarize</command> statement will group rows, and then the nested <command>subcontext</command> statement will iterate through each row in the current summary group.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>summarize</command> ($services) 
    <command>by</command> (%effective_start_date) 
    <command>where</command> (%service_type == "voice") 
    <command>sortBy</command> (%effective_start_date)
{
    printf("account has %d service(s) starting on %s\n", 
           context_rows(),
           format_date(%effective_start_date, "YYYY-MM-DD HH:mm:SS"));
    <command>subcontext</command> <command>sortDescendingBy</command> (%effective_end_date)
    {
        printf("\tservice %s: ends: %s\n", %msisdn, format_date(%effective_end_date, "YYYY-MM-DD HH:mm:SS"));
    }
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>
</sect1>

<sect1 id="Subroutines">
<title>Subroutines</title>

<para>A subroutine is declared in Qore by using the key word <command>sub</command> as follows:</para>

<programlisting><command>sub</command> <replaceable>subroutine_name</replaceable>([<replaceable>variable1, variable2, ...</replaceable>])
{
    <replaceable>statements;</replaceable>
}
</programlisting>

<para>Variables listed in parentheses by the subroutine name automatically get local lexical scoping. In order to process a variable number of arguments to a function, the <code>$argv</code> variable (local variable) is instantiated as a list with the remaining arguments passed to the subroutine.</para>

<para>Subroutines can use the <command>return</command> statement to provide a return value. Subroutine names must be valid Qore identifiers.</para>

<note><para>Variables passed as function arguments are passed by value by default, unless the caller places a "\" character before an lvalue in the argument list. In this case the subroutine must have a parameter defined to accept the variable passed by reference. Any changes to the local variable will be reflected in the original variable for variables passed by reference. Also note that it is illegal to pass an argument by reference in a background expression.</para></note>

<para>Subroutines can return values to the calling expression by using the <command>return</command> statement, with the following syntax:</para>

<programlisting><command>return</command> <replaceable>expression</replaceable>;</programlisting>

<para>Here is an example subroutine declaration for a function returning a value:</para>

<programlisting>#!/usr/bin/qore
#
# subroutine declaration example

<command>sub</command> print_string($string)
{
    print("%s\n", $string);
    <command>return</command> 1;
}
</programlisting>

<para>Subroutines may also be recursive.  Here is an example of a recursive Qore subroutine definition implementing the Fibonacci function:</para>

<programlisting>#!/usr/bin/qore
#
# recursive subroutine example

<command>sub</command> fibonacci($num)
{
    <command>if</command> ($num == 1)
        <command>return</command> 1;
    <command>return</command> $num * fibonacci($num - 1);
}
</programlisting>

<note>
<para>Function names are resolved during the second parse pass; therefore functions do not need to be declared before being referenced. This allows an easy definition of 2 or more self-referencing functions.</para></note>  

</sect1>
<sect1 id="Namespaces">
<title>Namespaces</title>

<para>Namespaces allow constants, classes, and even other namespaces with the same name to co-exist in the same program by defining them in separate namespaces. Constants, classes, and sub-namespaces can be declared to belong to a particular namespace either by defining them in-line within a namespace declaration, or by including the namespace name/path prepended to the constant, class, or namespace declaration separated by two colons "::".</para>

<para>If the user does not specify the parent namespace with a namespace path in constant, class, or namespace declarations, the declaration will be by default in the unnamed default root namespace.</para>

<sect2 id="Namespace_Declarations">
<title>Namespace Declarations</title>

<para>In-line namespace declaration:</para>

<programlisting><command>namespace</command> [<replaceable>namespace_path</replaceable>::]<replaceable>namespace_identifier</replaceable> 
{
    [<replaceable>constant_declarations</replaceable>]
    [<replaceable>class_declarations</replaceable>]
    [<replaceable>sub-namespace-declarations</replaceable>]
}
</programlisting>

<para>Out of line namespace declaration:</para>

<programlisting><command>namespace</command> [<replaceable>namespace_path</replaceable>::]<replaceable>namespace_identifier</replaceable>;
</programlisting>

</sect2>
<sect2 id="Namespace_Resolution">
<title>Namespace Resolution</title>

<para>Namespaces can either be resolved by giving a path to the constant, class, or namespace desired, or by leaving out the namespace path and allowing the system to search for the constant, class, or namespace. In either case, a breadth-first search of the namespace tree is made for a match. If a namespace path is included, then the tree is searched for the first namespace match. and, if the rest of the declaration cannot be matched, the search continues in the entire namespace tree until a complete match is found.</para>

<para>Namespace paths look like the following:</para>

<para><replaceable>starting_namespace</replaceable>::[<replaceable>sub-namespaces</replaceable>::]<replaceable>constant|class|namespace</replaceable></para>

</sect2>
<sect2 id="System_Namespaces">
<title>System Namespaces</title>


<para>All Qore-language constants and classes are defined in the Qore namespace or in a subnamespace of the Qore namespace. The Qore namespace is a direct child of the unnamed default root namespace (::).</para>

<para>For detailed information on all constants and classes defined in system namespaces, see <link linkend="System_Namespaces_and_Class_Library">System Namespaces and Class Library</link>.</para>
</sect2>
</sect1>
<sect1 id="Constants">
<title>Constants</title>

<para>Constant definitions allow programmers to refer to values with Qore identifiers rather than using the value.  Constants are defined with the following syntax:</para>

<para><command>const</command> [<replaceable>namespace_path</replaceable>::]<replaceable>constant_identifier</replaceable> = <replaceable>value</replaceable>;</para>

<note><para>The value cannot require run-time evaluation (executes a function, has a variable reference, uses an operator that changes values, etc) or a parse exception will be raised.</para></note>

</sect1>
<sect1 id="Classes">
<title>Classes</title>

<para>Objects are instantiations of a Qore class.  Classes define private members and methods, which are functions that operate only on the objects of that class.</para>

<para>Classes are declared with the following syntax:</para>

<programlisting><command>class</command> [<replaceable>namespace_path::</replaceable>...]<replaceable>class_identifier</replaceable> [<command>inherits</command> [<command>private</command>] [<replaceable>namespace_path::</replaceable>...]<replaceable>class_identifier</replaceable>[, ...]]
{
    [<command>private </command> <replaceable>$.var1[, ...]</replaceable>;]

    [<command>synchronized</command>] [<command>private</command>] [<replaceable>namespace_path</replaceable>::]<replaceable>method_name_identifier</replaceable>([$var1, $var2, ...])
    {
         <replaceable>statements</replaceable>;
    }
    ...
}
</programlisting>

<para>Alternatively objects can be defined out of line as follows:</para>

<programlisting><command>class</command> [<replaceable>namespace_path::</replaceable>]<replaceable>class_identifier</replaceable> [<command>inherits</command> [<command>private</command>] [<replaceable>namespace_path::</replaceable>...]<replaceable>class_identifier</replaceable>[, ...]];

[<command>synchronized</command>] [<command>private</command>] [<replaceable>namespace_path::</replaceable>]<replaceable>class_identifier</replaceable>::<replaceable>method_identifier</replaceable>([$var1, $var2, ...])
{
    <replaceable>statements</replaceable>;
}
</programlisting>

<note><para>Private members can only be declared in an in-line class definition (the first example above).</para></note>

<note><para>In a class hierarchy, base class constructor methods can be explicitly specified using a special syntax unique to subclass constructor methods.  Please see <link linkend='Class_Inheritance'>Class Inheritance</link> for more information.</para></note>

<note><para>It's possible to write purely object-oriented scripts/programs in Qore by defining an application class and using the -x or --exec-class command-line arguments to tell Qore to instantiate the class instead of doing normal top-level execution (in fact, the --exec-class arguments disallow the use of top-level statements entirely).  For more information, please see <link linkend="Command-Line_Parsing">Command-Line Parsing</link> and <link linkend="Parse_Directives">Parse Directives</link>.</para></note>

<sect2 id="Private_and_Synchronized_Methods">
<title>Private and Synchronized Methods</title>

<para>Methods declared with the <command>private</command> keyword can only be called by other member functions of the same class.  Any attempt to call these methods from outside the class will result in a run-time exception.</para>

<para>Methods declared with the <command>synchronized</command> keyword will only run in one thread at a time.</para>
</sect2>

<sect2 id="Constructors_Destructors_and_Other_Special_Methods">
<title>Constructors, Destructors, and Other Special Methods</title>

<para>All class methods are optional, but some methods have a special meaning.</para>

<table><title>Special Methods</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Name</para></entry>
    <entry><para>Description</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para><code>constructor()</code></para></entry>
    <entry><para>Called when objects are created with the <command>new</command> operator. User code may not explicitly call <code>constructor()</code> methods.  In a class tree, <code>constructor()</code> methods are called for base classes first in left-to-right, depth-first declaration order.</para></entry>
  </row>
  <row>
    <entry><para><code>copy()</code></para></entry>
    <entry><para>When a user explicitly calls a copy method, Qore will generate a new object with references to the same members as the source object.  Then, if there are any base classes, base class <code>copy()</code> methods are called in the same order as the <code>constructor()</code> methods.  If a <code>copy()</code> method is defined, it will be run in the new object with a reference to the old object passed as the first argument.  Any other arguments passed to the <code>copy()</code> method are ignored.</para></entry>
  </row>
  <row>
    <entry><para><code>destructor()</code></para></entry>
    <entry><para>Called when objects go out of scope or are explicitly deleted. User code may not explicitly call <code>destructor()</code> methods.  In a class tree, <code>destructor()</code> methods are called for base classes in the opposite order in which the constructors are called</para></entry>
  </row>
  <row>
    <entry><para><code>memberGate()</code></para></entry>
    <entry><para>Called when read access is attempted to private member or members that do not exist in the current object.  In a class tree, <code>memberGate()</code> methods are not inherited.</para></entry>
  </row>
  <row>
    <entry><para><code>methodGate()</code></para></entry>
    <entry><para>Called when methods are called on the object that do not exist in the current object.  In a class tree, <code>methodGate()</code> methods are not inherited.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>Within class methods, members of the current object can be referred to with a special syntax as follows:</para>

<programlisting>$.<replaceable>member_name_identifier</replaceable></programlisting>

<para>Furthermore the automatic variable <code>$self</code> is instantiated which represents the current object (similar to the <code>this</code> in C++ or Java). Therefore if you need to access hash members which are not valid Qore identifiers, then enclose the member name in double quotes after the dot operator as follows: </para>

<programlisting>$self."&amp;member-name"</programlisting>

<para>The automatic <code>$argv</code> local variable is instantiated as usual in all class methods where there are more arguments than variables declared in the method declaration.</para>

</sect2>

<sect2 id="Class_Inheritance">
<title>Class Inheritance</title>

<para>Class inheritance is a powerful concept for easily extending and resuing object-oriented code, but is also subject to some limitations.  This section will explain how class inheritance works in Qore.</para>

<para>Classes inherit the methods of a parent class by using the <command>inherits</command> as specified above.  Multiple inheritance is supported; a single Qore class can inherit one or more classes.  When a class is inherited by another class, it is called a base class.  Private inheritance is speficied by including the keyword <command>private</command> before the inherited class name.  When a class is privately inherited, it means that the inherited class' public members are treated as private members in the context of accesses outside the class.</para>

<para>It is not legal to directly inherit the same class more than once; that is; it is not legal to list the same class more than once after the <command>inherits</command> keyword.  However, it is possible that a base class could appear more than once in the inheritance tree if that class is inherited separately by two or more classes in the tree.  In this case, the base class will actually only be inherited once in the subclass, even though it appears in the inheritance tree more than once.  This must be taken into consideration when designing class hierarchies, particularly if base class constructor parameters for that class are explicitly provided in a different way by the inheriting classes.</para>

<note><para>Class members only exist once for each object; therefore if classes in an inheritance tree have different uses for members with the same name, then a class hierarchy built of such classes will probably not function properly.</para></note>

<para>Subclasses can give explicit arguments to their base class constructors using a special syntax (only available to subclass constructors) similar to the C++ syntax for the same purpose as follows:</para>

<programlisting><replaceable>class_name</replaceable>::constructor([$var1[, ...]) : <replaceable>base_class_identifier</replaceable>(<replaceable>expression(s)</replaceable>)[, ...]
{
    <replaceable>statements</replaceable>;
}
</programlisting>

<para>Here is a concrete example of giving arguments to an inherited base class:</para>
<programlisting><command>class</command> XmlRpcClient::XmlRpcClient <command>inherits</command> HTTPClient::HTTPClient
{
    # calls the base class HTTPClient constructor, overrides the "protocols" key to "xmlrpc"
    constructor($opts) : HTTPClient::HTTPClient($opts + ( "protocols" : "xmlrpc" ))
    ...
}
</programlisting>

<para>Because base class constructors are executed before subclass constructors, the only local variables in the constructor that can be referenced are those declared in the subclass constructor declaration (if any).</para>

<note><para>Base classes that give explicit arguments to their base class constructors can be overridden by subclasses by simply listing the base class in the base class constructor list and providing new arguments.</para></note>

</sect2>

<sect2 id="Object_Scope_and_References">
<title>Object Scope and References</title>

<para>In Qore (like Java) objects are by default referenced and not copied.  That means that passing an object to a function that modifies the object will by default modify the original object and not a copy.</para>

<para>To explicitly generate a copy of an object, the <code>copy()</code> constructor must be called.  This is a special method that exists implicitly for every class even if it is not explicitly defined (like <code>constructor()</code> and <code>destructor()</code> methods).  The implicit behavior of the <code>copy()</code> constructor is to create a new object with new members that are copies of the original members (except objects are once again referenced).  Then, if any <code>copy()</code> method exists, it will be executed in the new object, passing a reference to the old object as the first paramter.</para>

<note>
<para>In a class hierarchy <code>copy()</code> methods are called in the same order as <code>constructor()</code> methods.</para>
</note>

<note>
<para>Not all built-in classes can be copied.  Classes not supporting copying will throw an exception when the <code>copy()</code> methods are called.  See the documentation for each class for more information.</para>
</note>

</sect2>

<sect2 id="Object_Scope_and_Threading">
<title>Object Scope and Threading</title>

<para>An object's destructor is called when it goes out of scope and the last thread running any of the object's methods returns from the object method, or if the destructor is called explicitly with the <command>delete</command> statement.</para>

<para>This means that an object assigned to a local variable, but has a running method in another thread (for example, by launching the method explicitly with the <command>background</command> expression), will not be deleted until the last thread terminates.</para>

<note>
<para>If an object spawns an object method in another thread using the <command>background</command> operator, that object will remain in scope until the last thread terminates or it's <code>destructor()</code> method is explicitly called with the <command>delete</command> operator. This means, for example, that objects assigned to local variables can exist for longer than the scope of their host variable if they have one or more methods running in other threads.</para>
</note>

<para>However, if an object with running threads is explicitly deleted, if this case is not handled in the object's <code>destructor()</code> method (by ensuring that all other running threads terminate gracefully), exceptions will be thrown in other threads at any attempt to access the already-deleted object.</para>

<para>For more information about threading, please see the following section <link linkend="Threading">Threading</link></para>

</sect2>
</sect1>

<sect1 id="Threading">
  <title>Threading</title>

  <para>The Qore language is thread-safe and Qore programs should not crash the Qore executable due to threading errors.  Threading errors should only cause application errors.</para>

  <sect2 id="Creating_and_Terminating_Threads">
    <title>Creating and Terminating Threads</title>

    <para>New threads are created with the <link linkend="Background_Operator"><command>background</command> operator</link>.  This operator executes the expression given as an argument in a new thread and returns the TID of the new thread to the calling thread.  This is most useful for calling user subroutines or object methods designed to run in a separate thread.</para>

    <para>To terminate a thread, the <link linkend="thread_exit_Statements"><command>thread_exit</command> statement</link> should be called, as calling the <link linkend="exit">exit() function</link> will terminate the entire UNIX process (and therefore all threads) immediately.</para>

  </sect2>
  <sect2 id="Threading_And_Variables">
    <title>Threading and Variables</title>
    <para>All global variables are shared in Qore programs, while local variables (declared with <command>my</command>) are always local to each thread, regardless of location. </para>
    <para>That means that even if a variable is declared with <command>my</command> at the top level, each thread will have its own copy of the variable.</para>
    <para>To have the equivalent of global thread-local variables, see the <link linkend="save_thread_data">save_thread_data()</link> and <link linkend="get_thread_data">get_thread_data()</link> in the <link linkend="Threading_Functions">Threading Functions</link> section.</para>
  </sect2>

  <sect2 id="Thread_Synchronization_and_Inter-Thread_Communication">
    <title>Thread Synchronization and Inter-Thread Communication</title>

    <para>The <command>synchronized</command> keyword can be used before subroutine or class method definitions in order to guarantee that the function or method call will only be executed in one thread at a time.  As in Java, this keyword can also be used safely with recursive functions and methods (internally an <link linkend="Qore::Thread::RMutex_Class">RMutex</link> object is used to guarantee thread-exclusivity and allow recursion).</para>

    <para>The following classes are useful when developing multi-threaded Qore programs:</para>

    <table>
      <title>Classes Useful With Threading</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Class</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Mutex_Class">Mutex</link></para></entry>
	    <entry><para>A mutual-exclusion thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::RMutex_Class">RMutex</link></para></entry>
	    <entry><para>A recursive mutual-exclusion thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Gate_Class">Gate</link></para></entry>
	    <entry><para>A keyed mutual-exclusion recursive thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::RWLock_Class">RWLock</link></para></entry>
	    <entry><para>A read-write thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Condition_Class">Condition</link></para></entry>
	    <entry><para>Allows Qore programs to block until a certain condition becomes true.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Counter_Class">Counter</link></para></entry>
	    <entry><para>A blocking counter class.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Queue_Class">Queue</link></para></entry>
	    <entry><para>A thread-safe, blocking queue class (useful for message passing).</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Sequence_Class">Sequence</link></para></entry>
	    <entry><para>A simple, thread-atomic sequence object (increment-only).</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <para>The following functions assist writing safe and efficient multi-threaded Qore programs:</para>

    <table>
      <title>Thread Functions</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Function</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="save_thread_data">save_thread_data()</link></para></entry>
	    <entry><para>Saves a thread-local value against a key.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="get_all_thread_data">get_all_thread_data()</link></para></entry>
	    <entry><para>Retrieves the entire thread-local hash.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="get_thread_data">get_thread_data()</link></para></entry>
	    <entry><para>Retrieves a thread-local value based on a key.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="delete_all_thread_data">delete_all_thread_data()</link></para></entry>
	    <entry><para>Deletes the entire thread-local data hash.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="delete_thread_data">delete_thread_data()</link></para></entry>
	    <entry><para>Delete the value of a key in the thread-local data hash.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="gettid">gettid()</link></para></entry>
	    <entry><para>Gets the thread's TID (thread identifier)</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="thread_list">thread_list()</link></para></entry>
	    <entry><para>Returns a list of TIDs of running threads</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="num_threads">num_threads()</link></para></entry>
	    <entry><para>Returns the number of running threads</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
    
  </sect2>

<sect2 id="Deadlocks">
  <title>Deadlocks</title>
  
  <para>Currently there is no deadlock detection in the Qore language. </para>

  <para>Deadlocks can only be caused by user code, for example, by trying to lock the same Mutex twice in the same thread without unlocking it between the two Mutex::lock() calls.</para>

  <para>In this case, the affected thread(s) will hang and the qore process will have to be killed manually.</para>
</sect2>
</sect1>

<sect1 id="Exception_Handling">
  <title>Exception Handling</title>

  <para>Exceptions are errors that can only be handled using a <link linkend='try_and_catch_Statements'><command>try catch</command> block</link>.  Any exception that is thrown in a <command>try</command> block will immediately cause execution of that thread to begin with the first statement of the <command>catch</command> block, regardless of the position of the program pointer of the running thread, even if nested subroutines or object method calls have been made.</para>

  <para>Exceptions can be thrown by the Qore system for a number of reasons, see the documentation for each function and object method for details.</para>

  <para>Programmers can also throw exceptions explicitly by using the <link linkend="throw_Statements"><command>throw</command></link> and <link linkend="rethrow_Statements"><command>rethrow</command></link> statements.</para>

  <para>Information about the exception, including the context in which the exception occurred, is saved in the exception hash, which can be retrieved by using a parameter variable in the catch block (for more information about <command>try catch</command> blocks, see <link linkend='try_and_catch_Statements'>try and catch Statements</link>).</para>

  <para>The exception hash contains the following members:</para>

  <table>
    <title>Exception hash keys</title>
    <tgroup cols='3' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Name</para></entry>
	  <entry><para>Type</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>type</para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>"System" or "User" depending on exception type</para></entry>
	</row>
	<row>
	  <entry><para>file</para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>File name of file where exception occurred</para></entry>
	</row>
	<row>
	  <entry><para>line</para></entry>
	  <entry><para>integer</para></entry>
	  <entry><para>Line number where exception occurred</para></entry>
	</row>
	<row>
	  <entry><para>callStack</para></entry>
	  <entry><para>list of hashes</para></entry>
	  <entry><para>Backtrace information</para></entry>
	</row>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>any</para></entry>
	  <entry><para>This key is populated with the value of the first expression of the <command>throw</command> statement.  For system exceptions, this is a string giving the exception code.</para></entry>
	</row>
	<row>
	  <entry><para>desc</para></entry>
	  <entry><para>any</para></entry>
	  <entry><para>This key is populated with the value of the second expression of the <command>throw</command> statement (if a list was thrown).  For system exceptions, this is a string giving a text description of the error.</para></entry>
	</row>
	<row>
	  <entry><para>arg</para></entry>
	  <entry><para>any</para></entry>
	  <entry><para>This key is populated with the value of the third expression of the <command>throw</command> statement (if a list was thrown).  For system exceptions, this is not populated.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <table id="Call_Stack_Description">
    <title>Call Stack Description</title>
    <tgroup cols='3' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Name</para></entry>
	  <entry><para>Type</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>function</para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>function name </para></entry>
	</row>
	<row>
	  <entry><para>line</para></entry>
	  <entry><para>integer</para></entry>
	  <entry><para>line number</para></entry>
	</row>
	<row>
	  <entry><para>file</para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>file name</para></entry>
	</row>
	<row>
	  <entry><para>type</para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>Exception Type (ET_*) constants; see <link linkend="Qore_Exception_Constants">Exception Constants</link> for values.</para></entry>
	</row>
	<row>
	  <entry><para>typecode</para></entry>
	  <entry><para>integer</para></entry>
	  <entry><para>Call Type (CT_*) constants; see <link linkend="Qore_Exception_Constants">Exception Constants</link> for values.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>System exceptions always throw 2 values, populating the "err" and "desc" keys of the exception hash, giving the exception string code and the exception description string, respectively. User exceptions have no restrictions, any values given in the throw statement will be mapped to exception keys as per the table above.</para>

</sect1>

  <sect1 id="XML_Integration">
    <title>XML Integration</title>

    <para>XML provides an excellent way to describe hierarchical data, and Qore allows for easy serialization and deserialization between XML strings and Qore data structures.</para>

    <para>Note that XML attributes are represented in Qore data structures in a hash key named <code>^attributes^</code>.  The value of this key should be a hash, and each member of this hash will represent an attribute-value pair.</para>
    
    <table>
      <title>Functions For XML Serialization and Deserialization</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Function Name</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLFragment">makeFormattedXMLFragment()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string with formatting without an XML header.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLString">makeFormattedXMLString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string with formatting and an XML header.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLFragment">makeXMLFragment()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string without an XML header or formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLString">makeXMLString()</link></para></entry>
	    <entry><para>Serializes a hash into a complete XML string with an XML header and without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXML">parseXML()</link></para></entry>
	    <entry>parses an XML string and returns a Qore hash structure.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <para>XML-RPC is a lightweight but powerful XML over HTTP web service protocol.  Qore includes builtin support for this protocol.  You can find more information about XML-RPC, including specifications and examples at <ulink url="http://xmlrpc.org">http://xmlrpc.org</ulink>.</para>
    
    <table>
      <title>Functions Providing XML-RPC Functionality</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Function Name</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCCallString">makeFormattedXMLRPCCallString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCCallStringArgs">makeFormattedXMLRPCCallStringArgs()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call without formatting, taking a single list argument for the argument list.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCFaultResponseString">makeFormattedXMLRPCFaultResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC fault response without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCResponseString">makeFormattedXMLRPCResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC response without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCValueString">makeFormattedXMLRPCValueString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string in XML-RPC Value format without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCCallString">makeXMLRPCCallString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCCallStringArgs">makeXMLRPCCallStringArgs()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call without formatting, taking a single list argument for the argument list.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCFaultResponseString">makeXMLRPCFaultResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC fault response without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCResponseString">makeXMLRPCResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC response without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCValueString">makeXMLRPCValueString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string in XML-RPC Value format without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXMLRPCCall">parseXMLRPCCall()</link></para></entry>
	    <entry>deserializies an XML-RPC call string, returning a Qore hash respresenting the call information.</entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXMLRPCResponse">parseXMLRPCResponse()</link></para></entry>
	    <entry>deserializies an XML-RPC response string, returning a Qore hash respresenting the response information.</entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXMLRPCValue">parseXMLRPCValue()</link></para></entry>
	    <entry>deserializies an XML-RPC value tree, returning a Qore hash respresenting the information.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>
</chapter>

